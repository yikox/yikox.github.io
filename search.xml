<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>多线程学习笔记</title>
      <link href="/2022/01/11/duo-xian-cheng-bi-ji/"/>
      <url>/2022/01/11/duo-xian-cheng-bi-ji/</url>
      
        <content type="html"><![CDATA[<h2 id="线程创建"><a href="#线程创建" class="headerlink" title="线程创建"></a>线程创建</h2><h3 id="线程ID"><a href="#线程ID" class="headerlink" title="线程ID"></a>线程ID</h3><p>线程ID类型是<code>pthread_t</code>，因此不可以直接使用整数判断，下面给出判断函数</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_equal</span><span class="params">(tid1,tid2)</span></span>;</span><br><span class="line"><span class="comment">//相等返回非0，不相等返回0</span></span><br></pre></td></tr></table></figure><p>以及获取自身线程ID的函数</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">pthread_t</span> <span class="title">pthread_self</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br></pre></td></tr></table></figure><h3 id="线程创建-1"><a href="#线程创建-1" class="headerlink" title="线程创建"></a>线程创建</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="keyword">pthread_t</span> ntid;<span class="comment">//线程id变量</span></span><br><span class="line"><span class="keyword">int</span> err=<span class="built_in">pthread_create</span>(线程ID地址，线程属性，线程运行函数，函数参数）</span><br><span class="line"><span class="keyword">if</span>(err!=<span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;cam&#x27;t create thread&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="线程终止"><a href="#线程终止" class="headerlink" title="线程终止"></a>线程终止</h2><h3 id="线程退出"><a href="#线程退出" class="headerlink" title="线程退出"></a>线程退出</h3><p>任意一线程调用exit函数都会将<strong>整个进程</strong>结束掉，如果想要结束某个线程，而不终止整个进程的话有以下三种办法：</p><ul><li>返回 <code>return</code></li><li>被同一进程的其他线程取消<code>int pthread_cancel(线程ID)</code></li><li>调用<code>pthread_exit</code></li></ul><h3 id="获取已结束线程的返回码"><a href="#获取已结束线程的返回码" class="headerlink" title="获取已结束线程的返回码"></a>获取已结束线程的返回码</h3><p>当一个线程被<code>return</code> 或者<code>pthread_exit</code>结束掉时，我们可使用<code>pthread_join</code>函数去获取已结束线程的返回码。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_join</span><span class="params">(已结束线程ID，保存返回码的二重指针)</span></span>;</span><br><span class="line"><span class="comment">//返回的是一个指针，要获取指针的值，把获取的指针保存在指针中，所以是二重指针</span></span><br><span class="line"><span class="comment">//调用时输入的是指针的地址</span></span><br></pre></td></tr></table></figure><p><strong>当已结束的线程被<code>pthread_join</code>调用时，会把线程置于分离状态，这样资源就可以恢复</strong></p><h3 id="线程清理处理程序"><a href="#线程清理处理程序" class="headerlink" title="线程清理处理程序"></a>线程清理处理程序</h3><p>线程可以安排在退出时要执行的操作，一个线程可以安排多个处理程序，但是安排在<strong>栈</strong>中，注意调用顺序<strong>后进先出</strong>。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">pthread_cleanup_push</span><span class="params">(处理函数，参数)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">pthread_cleanup_pop</span><span class="params">(参数)</span></span>;<span class="comment">//参数为0时，清理函数将不被调用</span></span><br></pre></td></tr></table></figure><p>注：<strong>return的退出不会触发清理程序</strong>，<code>pthread_exit</code>会触发。当不需要的时候可以调用pop函数删除清理程序。</p><h2 id="线程同步"><a href="#线程同步" class="headerlink" title="线程同步"></a>线程同步</h2><h3 id="互斥量"><a href="#互斥量" class="headerlink" title="互斥量"></a>互斥量</h3><p>为了保证线程同步,多线程编程构建了一种锁的形式，当一个线程要操作某些变量的时候把这些变量的锁锁住，这样当其他线程想要操作这些变量的时候，就需要等待该线程操作完成并解锁。</p><p>锁即本小章的互斥量(<strong>下文中以mutex表示互斥量</strong>)</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pthread_mutex_t</span> mutex;</span><br></pre></td></tr></table></figure><p>互斥量需要初始化</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_mutex_init</span><span class="params">(*mutex，属性)</span></span>;<span class="comment">//如果初始华为默认属性的互斥量就把属性置为NULL</span></span><br></pre></td></tr></table></figure><p>可以静态初始化</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pthread_mutex_t</span> f_lock = PTHREAD_MUTEX_INITIALIZER;</span><br></pre></td></tr></table></figure><p>如若用动态内存分配的方式创建互斥量，在释放内存时需要先行调用</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_mutex_destroy</span><span class="params">(*mutex)</span></span>;</span><br></pre></td></tr></table></figure><ul><li>加锁和解锁</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_mutex_lock</span><span class="params">(*mutex)</span></span>;<span class="comment">//当互斥量被别的线程锁住时，lock函数会阻塞掉本线程</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_mutex_trylock</span><span class="params">(*mutex)</span></span>;<span class="comment">//当互斥量被别的线程锁住时，trylock函数不会阻塞掉本线程，而会返回EBUSY</span></span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_mutex_unlock</span><span class="params">(*mutex)</span></span>;<span class="comment">//解锁</span></span><br></pre></td></tr></table></figure><ul><li>设定等待锁的时间</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_mutex_timelock</span><span class="params">(*mutex,*tsptr)</span></span>;<span class="comment">//阻塞等待tsptr的时间</span></span><br></pre></td></tr></table></figure><p>eg:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">timespec</span> <span class="title">tout</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//获取当前时间</span></span><br><span class="line">clock_gettime(CLOCK_REALTIME,&amp;tout);</span><br><span class="line"></span><br><span class="line"><span class="comment">//打印时间</span></span><br><span class="line">tmp = locaktime(&amp;tout.tv_sec);</span><br><span class="line"><span class="built_in">sprintf</span>(buf,<span class="keyword">sizeof</span>(buf),<span class="string">&quot;%r&quot;</span>,tmp);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%s&quot;</span>,buf);</span><br><span class="line"></span><br><span class="line"><span class="comment">//等待10秒</span></span><br><span class="line">tout.tv_sec+=<span class="number">10</span>;</span><br><span class="line">err = pthread_mutex_timelock(&amp;mutex,&amp;tout);</span><br></pre></td></tr></table></figure><h3 id="读写锁"><a href="#读写锁" class="headerlink" title="读写锁"></a>读写锁</h3><p>读写锁也叫共享互斥锁，它有三种工作状态，读锁，写锁和无锁，读锁状态时可以允许其他线程进行读取，写锁状态只能单独使用。注：当写锁申请时会阻塞掉后面的读锁（避免被读锁长期占据而无法满足写锁）</p><p>读写锁变量</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pthread_rwlock_t</span> rwlock;</span><br><span class="line">​</span><br><span class="line"><span class="comment">//初始化</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_rwlock_init</span><span class="params">(*rwlock,*attr)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_rwlock_destory</span><span class="params">(*rwlock)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//锁与解锁</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_rwlock_rdlock</span><span class="params">(*rwlock)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_rwlock_wrlock</span><span class="params">(*rwlock)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_rwlock_unlock</span><span class="params">(*rwlock)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//条件版本</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_rwlock_tryrdlock</span><span class="params">(*rwlock)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_rwlock_trywrlock</span><span class="params">(*rwlock)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//带超时版本</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_rwlock_timerdlock</span><span class="params">(*rwlock,*tout)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_rwlock_timewrlock</span><span class="params">(*rwlock,*tout)</span></span>;</span><br></pre></td></tr></table></figure><h3 id="条件变量"><a href="#条件变量" class="headerlink" title="条件变量"></a>条件变量</h3><p> 用来等待某些操作完成，或者进行同步。</p><p>条件本身由互斥量进行保护。</p><p>条件变量<code>pthread_cond_t</code></p><p>初始化：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_cond_init</span><span class="params">(*cond,*attr)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_cond_destory</span><span class="params">(*cond)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_cond_wait</span><span class="params">(*cond,*mutex)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_cond_timewait</span><span class="params">(*cond,*mutex,*tsptr)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//发信号，换新等待的线程</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_cond_signal</span><span class="params">(*cond)</span></span>;<span class="comment">//唤醒一个及以上</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_cond_broadcast</span><span class="params">(*cond)</span></span>;<span class="comment">//</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="自旋锁"><a href="#自旋锁" class="headerlink" title="自旋锁"></a>自旋锁</h3><p>自旋锁在阻塞时不进行休眠，而是在获得锁之前一直处于忙等（自旋）阻塞状态。一般用于以下情况：锁被持有的时间<strong>短</strong>，而线程不希望在重新调度上花费太多成本。自旋锁在阻塞时，CPU不能做其他的事情。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pthread_spinlock_t</span> spin;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_spin_init</span><span class="params">(*spin,*attr)</span></span>;</span><br><span class="line"><span class="comment">//...同上</span></span><br></pre></td></tr></table></figure><h3 id="屏障"><a href="#屏障" class="headerlink" title="屏障"></a>屏障</h3><p>允许任意数量的线程等待，直到所有合作线程完成工作，而且线程不需要退出。当所有线程到达屏障后可以接着工作。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pthread_barrier_t</span> barrier;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_barrier_init</span><span class="params">(*barrier,*attr,count)</span><span class="comment">//count数量，允许运行前达到屏障的线程数量</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_barrier_destory</span><span class="params">(*barrier)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_barrier_wait</span><span class="params">(*barrier)</span></span>;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="线程属性"><a href="#线程属性" class="headerlink" title="线程属性"></a>线程属性</h2><p>在线程创建中我们在线程属性的参数输入了NULL作为默认值，这里我们将了解更多的线程属性，以及它们的作用。</p><p>线程属性一共有四个：</p><ul><li>detachstate：线程分离状态属性</li><li>guardsize：线程末尾的警戒缓冲区大小</li><li>stackaddr：线程栈的最低地址</li><li>stacksize：线程栈的最小长度</li></ul><p>线程属性使用一个<code>pthread_attr_t</code>变量来设定，使用<code>pthread_attr_init</code>初始化，使用<code>pthread_attr_destroy</code>反初始化。</p><h3 id="修改线程分离状态"><a href="#修改线程分离状态" class="headerlink" title="修改线程分离状态"></a>修改线程分离状态</h3><p>如果对某个线程的终止状态不感兴趣的话，可以使用<code>pthread_detach</code>函数让操作系统在线程退出时回收线程所占用的资源。但如果在创建线程时就知道不需要了解线程的终止状态，就可以修改线程属性中的detachstate属性，让线程一开始就处于分离状态。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*获取当前的detachstate线程属性*/</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_attr_getdetachstate</span><span class="params">(<span class="keyword">const</span> <span class="keyword">pthread_attr_t</span> *<span class="keyword">restrict</span> attr,<span class="keyword">int</span> *detachstate)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*设置attr变量的detachstate值，后面的参数可以是PTHREAD_CREATE_DETACHED和PTHREAD_CREATE_JOINABLE两种属性值*/</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_attr_setdetachstate</span><span class="params">(<span class="keyword">pthread_attr_t</span> *attr,<span class="keyword">int</span> *detachstate)</span></span>;</span><br></pre></td></tr></table></figure><h3 id="修改线程栈属性"><a href="#修改线程栈属性" class="headerlink" title="修改线程栈属性"></a>修改线程栈属性</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_attr_getstack</span><span class="params">(<span class="keyword">const</span> <span class="keyword">pthread_attr_t</span> *<span class="keyword">restrict</span> attr,</span></span></span><br><span class="line"><span class="params"><span class="function">                          <span class="keyword">void</span> **<span class="keyword">restrict</span> strackaddr,</span></span></span><br><span class="line"><span class="params"><span class="function">                          <span class="keyword">size_t</span> *<span class="keyword">restrict</span> stracksize)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_attr_setstack</span><span class="params">(<span class="keyword">pthread_attr_t</span>  attr,<span class="keyword">void</span> *strackaddr,<span class="keyword">size_t</span> stracksize)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*仅改变大小*/</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_attr_getstacksize</span><span class="params">(<span class="keyword">const</span> <span class="keyword">pthread_attr_t</span> *<span class="keyword">restrict</span> attr,</span></span></span><br><span class="line"><span class="params"><span class="function">                              <span class="keyword">size_t</span> *<span class="keyword">restrict</span> stracksize)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_attr_setstacksize</span><span class="params">(<span class="keyword">pthread_attr_t</span> *attr, <span class="keyword">size_t</span> stracksize)</span></span>;</span><br></pre></td></tr></table></figure><h3 id="修改线程缓冲区大小"><a href="#修改线程缓冲区大小" class="headerlink" title="修改线程缓冲区大小"></a>修改线程缓冲区大小</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_attr_getguardsize</span><span class="params">(<span class="keyword">const</span> <span class="keyword">pthread_attr_t</span> *<span class="keyword">restrict</span> attr,</span></span></span><br><span class="line"><span class="params"><span class="function">                              <span class="keyword">size_t</span> *<span class="keyword">restrict</span> stracksize)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_attr_setguardsize</span><span class="params">(<span class="keyword">pthread_attr_t</span> *attr,<span class="keyword">size_t</span> stracksize)</span></span>;</span><br></pre></td></tr></table></figure><h2 id="同步属性"><a href="#同步属性" class="headerlink" title="同步属性"></a>同步属性</h2><h3 id="互斥量属性"><a href="#互斥量属性" class="headerlink" title="互斥量属性"></a>互斥量属性</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//互斥量属性</span></span><br><span class="line"><span class="keyword">pthread_mutexattr_t</span> attr;</span><br><span class="line"></span><br><span class="line"><span class="comment">//初始化与反初始化</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_mutexattr_init</span><span class="params">(<span class="keyword">pthread_mutexattr_t</span> *attr)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_mutexattr_destroy</span><span class="params">(<span class="keyword">pthread_mutexattr_t</span> *attr)</span></span>;</span><br><span class="line"><span class="comment">//成功返回0，失败返回错误编号</span></span><br></pre></td></tr></table></figure><p>互斥量属性中，有三个值得注意的属性，分别是：进程共享属性，健壮属性，类型属性</p><ul><li><p>进程共享属性</p><p>进程共享属性的互斥量属性设为<code>PTHREAD_PROCESS_PRIVATE</code>，这样就是默认的属性，进程内部多个线程共用；如果进程共享属性互斥量设为<code>PTHREAD_PROCESS_SHARED</code>,从多个进程彼此之间共享的内存数据块中分配的互斥量就可以用于这些进程的同步。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_mutexattr_getpshared</span><span class="params">(<span class="keyword">const</span> <span class="keyword">pthread_mutexattr_t</span> *<span class="keyword">restrict</span> attr, </span></span></span><br><span class="line"><span class="params"><span class="function">                                 <span class="keyword">int</span> *<span class="keyword">restrict</span> pshared)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_mutexattr_setpshared</span><span class="params">(<span class="keyword">pthread_mutexattr_t</span> *attr, <span class="keyword">int</span> pshared)</span></span>;</span><br></pre></td></tr></table></figure></li><li><p>健壮属性</p><p>互斥量的健壮属性和之前的进程共享属性有关，当一个持有互斥量的进程终止时，需要解决互斥量的恢复问题。这种情况发生时，互斥量处于锁定状态，恢复起来困难，其他阻塞在这个锁的进程就会一直阻塞下去。健壮属性有两种属性：<code>PTHREAD_MUTEX_STALLED</code>及默认属性，等待互斥量解锁的应用程序会被有效地“拖住”，<strong>另一个取值<code>PTHREAD_MUTEX_ROBUST</code>时，当一个进程调用<code>pthread_mutex_lock</code>获取锁，而锁被另一个进程持有，且终止时没有解锁，此时进程会阻塞，但从<code>pthread_mutex_lock</code>返回的值为EOWNERDEAD而不是0，应用程序可以通过这个特殊的返回值得知，互斥量需要进行恢复。</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_mutexattr_getrobust</span><span class="params">(<span class="keyword">const</span> <span class="keyword">pthread_mutexattr_t</span> *<span class="keyword">restrict</span> attr, <span class="keyword">int</span> *<span class="keyword">restrict</span> rubust)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_mutexattr_setrobust</span><span class="params">(<span class="keyword">pthread_mutexattr_t</span> *attr, <span class="keyword">int</span> robust)</span></span>;</span><br></pre></td></tr></table></figure><ul><li>恢复：如果应用状态无法恢复，<strong>在线程对互斥量解锁以后，该互斥量将处于永久不可用状态？？？</strong>。为了避免这样的问题，线程可以调用<code>pthread_mutex_consistent</code>函数，指明与该互斥量相关的状态在互斥量解锁前时一致的。。unix环境p347页</li></ul></li><li><p>类型属性</p><p>互斥量类型属性控制互斥量的<strong>锁定特性</strong>，</p><ul><li>PTHREAD_MUTEX_NORMAL<ul><li>标准的互斥量类型，不做特殊的错误检查或死锁检测</li></ul></li><li>PTHREAD_MUTEX_ERRORCHECK<ul><li>提供错误检查</li></ul></li><li>PTHREAD_MUTEX_RECURSIVE<ul><li>允许同一线程在互斥量解锁前进行多次加锁（递归加锁）</li></ul></li><li>PTHREAD_MUTEX_DEFAULT<ul><li>默认类型，供给操作系统映射到标准类型或错误检查类型</li></ul></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_mutexattr_gettype</span><span class="params">(<span class="keyword">const</span> <span class="keyword">pthread_mutexattr_t</span> *<span class="keyword">restrict</span> attr, </span></span></span><br><span class="line"><span class="params"><span class="function">                              <span class="keyword">int</span> *<span class="keyword">restrict</span> type)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_mutexattr_settype</span><span class="params">(<span class="keyword">pthread_mutexattr_t</span> *attr, <span class="keyword">int</span> type)</span></span>;</span><br></pre></td></tr></table></figure><h3 id="读写锁属性"><a href="#读写锁属性" class="headerlink" title="读写锁属性"></a>读写锁属性</h3></li></ul><p>读写锁和互斥锁一样拥有属性，不过读写锁只支持<strong>进程共享属性</strong>。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//读写锁属性</span></span><br><span class="line"><span class="keyword">pthread_rwlockattr_t</span> attr;</span><br><span class="line"></span><br><span class="line"><span class="comment">//初始化与反初始化</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_rwlockattr_init</span><span class="params">(<span class="keyword">pthread_rwlockattr_t</span> *attr)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_rwlockattr_destroy</span><span class="params">(<span class="keyword">pthread_rwlockattr_t</span> *attr)</span></span>;</span><br><span class="line"><span class="comment">//成功返回0，失败返回错误编号</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_rwlockattr_getpshared</span><span class="params">(<span class="keyword">const</span> <span class="keyword">pthread_rwlockattr_t</span> *<span class="keyword">restrict</span> attr, </span></span></span><br><span class="line"><span class="params"><span class="function">                                  <span class="keyword">int</span> *<span class="keyword">restrict</span> pshared)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_rwlockattr_setpshared</span><span class="params">(<span class="keyword">pthread_rwlockattr_t</span> *attr, <span class="keyword">int</span> pshared)</span></span>;</span><br></pre></td></tr></table></figure><h3 id="条件变量属性"><a href="#条件变量属性" class="headerlink" title="条件变量属性"></a>条件变量属性</h3><p>条件变量定义了两个属性：<strong>进程共享属性</strong>和<strong>时钟属性</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//条件变量属性</span></span><br><span class="line"><span class="keyword">pthread_condattr_t</span> attr;</span><br><span class="line"></span><br><span class="line"><span class="comment">//初始化与反初始化</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_condattr_init</span><span class="params">(<span class="keyword">pthread_condattr_t</span> *attr)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_condattr_destroy</span><span class="params">(<span class="keyword">pthread_condattr_t</span> *attr)</span></span>;</span><br><span class="line"><span class="comment">//成功返回0，失败返回错误编号</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_condattr_getpshared</span><span class="params">(<span class="keyword">const</span> <span class="keyword">pthread_condattr_t</span> *<span class="keyword">restrict</span> attr,</span></span></span><br><span class="line"><span class="params"><span class="function">                                <span class="keyword">int</span> *<span class="keyword">restrict</span> pshared)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_condattr_setpshared</span><span class="params">(<span class="keyword">pthread_condattr_t</span> *attr, <span class="keyword">int</span> pshared)</span></span>;</span><br></pre></td></tr></table></figure><p>s时钟属性控制<code>pthread_cond_timewait</code>函数的超时参数采用的哪个时钟</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_condattr_getclock</span><span class="params">(<span class="keyword">const</span> <span class="keyword">pthread_condattr_t</span> *<span class="keyword">restrict</span> attr,</span></span></span><br><span class="line"><span class="params"><span class="function">                              <span class="keyword">clockid_t</span> *<span class="keyword">restrict</span> clock_id)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_condattr_setclock</span><span class="params">(<span class="keyword">pthread_condattr_t</span> *attr, <span class="keyword">clockid_t</span> clock_id)</span></span>;</span><br></pre></td></tr></table></figure><h3 id="屏障属性"><a href="#屏障属性" class="headerlink" title="屏障属性"></a>屏障属性</h3><p>屏障目前只定义了一个属性，<strong>进程共享属性</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//屏障属性</span></span><br><span class="line"><span class="keyword">pthread_barrierattr_t</span> attr;</span><br><span class="line"></span><br><span class="line"><span class="comment">//初始化与反初始化</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_barrierattr_init</span><span class="params">(<span class="keyword">pthread_barrierattr_t</span> *attr)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_barrierattr_destroy</span><span class="params">(<span class="keyword">pthread_barrierattr_t</span> *attr)</span></span>;</span><br><span class="line"><span class="comment">//成功返回0，失败返回错误编号</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_barrierattr_getpshared</span><span class="params">(<span class="keyword">const</span> <span class="keyword">pthread_barrierattr_t</span> *<span class="keyword">restrict</span> attr, </span></span></span><br><span class="line"><span class="params"><span class="function">                                  <span class="keyword">int</span> *<span class="keyword">restrict</span> pshared)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_barrierattr_setpshared</span><span class="params">(<span class="keyword">pthread_barrierattr_t</span> *attr, <span class="keyword">int</span> pshared)</span></span>;</span><br></pre></td></tr></table></figure><h2 id="重入"><a href="#重入" class="headerlink" title="重入"></a>重入</h2><p>暂略</p><h2 id="线程特定数据"><a href="#线程特定数据" class="headerlink" title="线程特定数据"></a>线程特定数据</h2><p>如果在函数体内不访问那些<a href="http://baike.baidu.com/view/261041.htm">全局变量</a>，不使用<a href="http://baike.baidu.com/view/612026.htm">静态</a><a href="http://baike.baidu.com/view/552847.htm">局部变量</a>，坚持只使用局部变量，写出的函数就将是可重入的。如果必须访问<a href="http://baike.baidu.com/view/261041.htm">全局变量</a>，记住利用互斥<a href="http://baike.baidu.com/view/1303265.htm">信号量</a>来保护全局变量。如果多个线程同时访问一个函数，而这个函数恰好也必须使用一个静态变量，那么，线程特定数据就是来解决这个问题的。</p><p>在分配特定数据前，需要先创建一个键</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_key_create</span><span class="params">(<span class="keyword">pthread_key_t</span> *keyp,<span class="keyword">void</span> (*destructor)(<span class="keyword">void</span> *))</span></span>;</span><br></pre></td></tr></table></figure><p>创建键的同时也可以为该键关联一个可选择的析构函数，当这个线程退出时，如果数据地址已经被置为非空值，那么析构函数就会被调用，它唯一的参数就是该数据地址。线程取消时，在最后的清理处理程序返回之后，析构函数才会被调用。当线程非正常（exit,_exit,Exit和abort等）退出就不会调用析构函数。</p><p>为了防止重复创建<strong>键</strong>，使用<code>pthread_once</code>函数解决</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pthread_once_t</span> initflag = PTHREAD_ONCE_INIT;<span class="comment">//必须为非本地变量（如全局变量或静态变量）</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_once</span><span class="params">(<span class="keyword">pthread_once_t</span> *initflag, <span class="keyword">void</span> (*initfn)(<span class="keyword">void</span>))</span></span>;</span><br></pre></td></tr></table></figure><p>键一但创建以后，就可以通过调用<code>pthread_setspecific</code>把键与线程特定数据关联起来，以及通过<code>pthread_getspecific</code>函数获取线程特定数据的地址。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">pthread_getspecific</span><span class="params">(<span class="keyword">pthread_key_t</span> key)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_setspecific</span><span class="params">(<span class="keyword">pthread_key_t</span> key,<span class="keyword">const</span> <span class="keyword">void</span> *value)</span></span>;</span><br></pre></td></tr></table></figure><p>对于所有的线程，我们可以调用<code>pthread_key_delete</code>来取消键与线程特定数据值之间的关联关系。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_key_delete</span><span class="params">(<span class="keyword">pthread_key_t</span> key)</span></span>;</span><br></pre></td></tr></table></figure><h2 id="取消选项"><a href="#取消选项" class="headerlink" title="取消选项"></a>取消选项</h2><p>有两个线程属性没有包含在<code>pthread_attr_t</code>结构中，它们时可取消状态和可取消类型</p><p><strong>可取消状态</strong>可以通过下面函数进行更改</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_setcancelstate</span><span class="params">(<span class="keyword">int</span> state,<span class="keyword">int</span> *oldstate)</span></span>;</span><br></pre></td></tr></table></figure><p>有两种状态<code>PTHREAD_CANCEL_ENABLE</code>和<code>PTHREAD_CANCEL_DISABLE</code>，当线程处于<code>PTHREAD_CANCEL_DISABLE</code>状态时，对<code>pthread_cancel</code>的调用并不会杀死线程，而是将取消请求置于挂起状态，直到线程取消状态再次变成<code>PTHREAD_CANCEL_ENABLE</code>时，线程将在下一个取消点对挂起的取消请求进行处理。</p><p>如果程序很长时间不会调用取消点定义的函数，可以自己调用<code>pthread_testcancel</code>函数在程序中添加取消点。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">pthread_testcancel</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br></pre></td></tr></table></figure><p><strong>可取消类型</strong>可以调用<code>pyhread_setcanceltype(int type, int *oldtype)</code>函数来修改取消类型，我们默认的取消类型是推迟取消，在线程到达取消点之前不会真正取消。取消类型有两个类型参数<code>PTHREAD_CANCEL_DEFERRED</code>和<code>PTHREAD_CANCEL_ASYNCHRONOUS</code>，异步取消与推迟取消不同，使用异步取消的线程可以在任意时间退出，不一定需要遇到取消点。</p><h2 id="线程和信号"><a href="#线程和信号" class="headerlink" title="线程和信号"></a>线程和信号</h2>]]></content>
      
      
      <categories>
          
          <category> UNIX环境高级编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 多线程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>GDB调试笔记</title>
      <link href="/2022/01/06/gdb-diao-shi-bi-ji/"/>
      <url>/2022/01/06/gdb-diao-shi-bi-ji/</url>
      
        <content type="html"><![CDATA[<h4 id="启动"><a href="#启动" class="headerlink" title="启动"></a>启动</h4><p>使用GDB在编译时需要加上-g，没有-g将看不见函数名，变量名，取代的是内存地址</p><h5 id="运行程序"><a href="#运行程序" class="headerlink" title="运行程序"></a>运行程序</h5><ul><li><p><code>gdb+执行文件/路径</code></p></li><li><p><code>gdb+执行文件+core文件</code></p></li><li><p><code>gdb+执行文件+PID（进程ID</code></p></li></ul><h5 id="调试已经运行的程序："><a href="#调试已经运行的程序：" class="headerlink" title="调试已经运行的程序："></a>调试已经运行的程序：</h5><ul><li>ps查看程序运行的PID，然后用上面的命令<code>gdb+执行文件+PID</code>（进程ID）</li><li>先用<code>pdb+执行文件</code> 关联上源代码，再用<code>attach</code>挂接进程的PID，用<code>detach</code>取消挂接的进程。</li></ul><h4 id="基础命令"><a href="#基础命令" class="headerlink" title="基础命令"></a>基础命令</h4><table><thead><tr><th>命令</th><th>功能</th></tr></thead><tbody><tr><td>l(list)</td><td>从第一行列出代码</td></tr><tr><td>break+行号</td><td>从16行设置断点</td></tr><tr><td>break func</td><td>设置断点在func入口处</td></tr><tr><td>info break</td><td>查看断点信息</td></tr><tr><td>r (run)</td><td>运行程序</td></tr><tr><td>n(next)</td><td>执行下一句，不会进入函数</td></tr><tr><td>s(step)</td><td>执行下一句，会进入函数</td></tr><tr><td>c(continue)</td><td>继续运行程序</td></tr><tr><td>p 变量名(print 变量名)</td><td>打印变量i的值</td></tr><tr><td>bt</td><td>查看函数堆栈</td></tr><tr><td>finish</td><td>退出函数</td></tr><tr><td>q</td><td>退出GDB</td></tr><tr><td>s(symbols)+file</td><td>从指定文件中读取符号表</td></tr><tr><td>c/core file</td><td>调试时core dump的core文件</td></tr><tr><td>d/directory file</td><td>加入一个源文件的搜索路径</td></tr></tbody></table><p><code>until</code>运行命令到退出循环体</p><p><code>stepi</code>和<code>nexti</code>单步执行一条机器指令</p><ul><li><p>打印结构体分行显示</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">set print pretty on </span><br></pre></td></tr></table></figure></li></ul><h4 id="暂停程序"><a href="#暂停程序" class="headerlink" title="暂停程序"></a>暂停程序</h4><h5 id="停止点"><a href="#停止点" class="headerlink" title="停止点"></a>停止点</h5><ul><li><p>断点<code>break+行号/函数</code></p></li><li><p><em>可以通过条件设置（break if 条件）</em>*</p></li><li><p><em>修改条件可以通过 condition+断点号+新条件</em>*</p></li><li><p>观察点<code>watch+变量名</code>（值发生变化会暂停）</p><ul><li><code>rwatch +变量名</code>（变量被读时暂停）</li><li><code>awatch+变量名</code>（读和写）</li></ul></li><li><p>捕捉点<code>catch</code></p></li></ul><h5 id="停止点维护"><a href="#停止点维护" class="headerlink" title="停止点维护"></a>停止点维护</h5><p>  <code>clear</code>清除所有停止点，可以加行号，函数指定清除的点<br>  <code>delete +断点号+范围</code><br>  <u><strong>clear和delete有啥区别</strong></u><br>  <code>disable和enable</code> 关掉和启动停止点</p><h5 id="特殊命令："><a href="#特殊命令：" class="headerlink" title="特殊命令："></a>特殊命令：</h5><ul><li><code>ignore+断点号+次数</code>程序运行时忽略该断点次数</li><li><code>commands+断点号 +命令列表+end</code>当断点触发时运行的命令列表中的命令，有利于自动测试</li></ul>  <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">commands 断点号</span><br><span class="line">  command-list</span><br><span class="line">end</span><br></pre></td></tr></table></figure><h5 id="信号"><a href="#信号" class="headerlink" title="信号"></a>信号</h5><p>信号是一种软中断，是一种处理异步事件的方法。一般来说，操作系统都支持许多信号。尤其是UNIX，比较重要应用程序一般都会处理信号。UNIX 定义了许多信号，比如SIGINT表示中断字符信号，也就是Ctrl+C的信号，SIGBUS表示硬件故障的信号；SIGCHLD表示子进程状态改变信号；SIGKILL表示终止程序运行的信号，等等。信号量编程是UNIX 下非常重要的一种技术。</p><p>定义GDB在调试过程中，当收到某种信号时的动作/停下/打印信息等等</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">handle+信号+处理方式</span><br></pre></td></tr></table></figure><p>处理方式：</p><p><code>Nostop</code>-不停下，但打印信息</p><p><code>stop</code>-停下</p><p>   <code>noprint</code>-不打印信息</p><p>   <code>pass</code></p><p><code>noignore</code>-GDB不处理该信号，交给被测程序处理</p><p><code>nopass</code></p><p><code>ignore</code>-不让被测程序处理</p><p><code>info signals</code></p><p><code>info handle</code></p><p>查看哪些信号被GDB检测中</p><h5 id="多线程"><a href="#多线程" class="headerlink" title="多线程"></a>多线程</h5><p>GDB可以指定断点在某一线程上**<code>break+行号+thread+线程ID</code>**</p><p>线程ID需要通过GDB查看，命令**<code>info threads</code>**</p><p>多线程调试时，可以取消线程轮转来进行单步调试（断到具体的函数，取消轮转，单步调试）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(gdb) set scheduler-locking on</span><br><span class="line">(gdb) set scheduler-locking off</span><br></pre></td></tr></table></figure><h4 id="检查信息"><a href="#检查信息" class="headerlink" title="检查信息"></a>检查信息</h4><h5 id="栈信息"><a href="#栈信息" class="headerlink" title="栈信息"></a>栈信息</h5><p>查看栈信息<code>backtrace/bt</code>可以加一个数n,表示只打印栈顶n行</p><p>查看当前栈详细信息<code>info frame/f</code></p><p>切换当前栈<code>frame/f</code>,同理加n，也可以用**<code>up和down</code>**上下移动</p><h5 id="搜索"><a href="#搜索" class="headerlink" title="搜索"></a>搜索</h5><p><code>forward-search 条件</code> 向前搜索</p><p><code>search 条件</code> 向后搜索</p><p><code>reverse-search 条件</code> 全局搜索</p><p>条件为正则表达式形式</p><h5 id="查看内存"><a href="#查看内存" class="headerlink" title="查看内存"></a>查看内存</h5><ul><li><p>查看源代码在运行时的地址</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">info line 行号/文件名：行号/文件名：函数名</span><br></pre></td></tr></table></figure></li><li><p>查看源程序的当前执行时的机器码</p> <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">disassemble func</span><br><span class="line"><span class="meta">#</span><span class="bash"> 会打印出函数func的汇编代码</span></span><br></pre></td></tr></table></figure></li><li><p>查看内存地址中的值</p> <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">examine命令，简写x</span></span><br><span class="line">x n/f/u addr</span><br><span class="line"><span class="meta">#</span><span class="bash">n 是一个正整数，表示显示内存的长度，也就是说从当前地址向后显示几个地址的内容。</span></span><br><span class="line"><span class="meta">#</span><span class="bash">f 表示显示的格式，参见上面。如果地址所指的是字符串，那么格式可以是s，如果地十是指令地址，那么格式可以是i。</span></span><br><span class="line"><span class="meta">#</span><span class="bash">u 表示从当前地址往后请求的字节数，如果不指定的话，GDB默认是4个bytes。u 参数可以用下面的字符来代替，b 表示单字节，h 表示双字节，w 表示四字节，g 表示八字节。当我们指定了字节长度后，GDB 会从指内存定的内存地址开始，读写指定字节，并把其当作一个值取出来。</span></span><br><span class="line"><span class="meta">#</span><span class="bash">n/f/u可以一起使用</span></span><br></pre></td></tr></table></figure></li></ul><h5 id="自动显示"><a href="#自动显示" class="headerlink" title="自动显示"></a>自动显示</h5><p>你可以设置一些自动显示的变量，当程序停住时，或是在你单步跟踪时，这些变量会自动显示。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">display 表达式</span><br><span class="line">display 地址</span><br><span class="line">display/格式 地址或表达式</span><br></pre></td></tr></table></figure><h5 id="查看寄存器"><a href="#查看寄存器" class="headerlink" title="查看寄存器"></a>查看寄存器</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">info registers</span><br><span class="line"><span class="meta">#</span><span class="bash">查看寄存器的情况。（除了浮点寄存器）</span></span><br><span class="line">info all-registers</span><br><span class="line"><span class="meta">#</span><span class="bash">查看所有寄存器的情况。（包括浮点寄存器）</span></span><br><span class="line">info registers &lt;regname ...&gt;</span><br><span class="line"><span class="meta">#</span><span class="bash">查看所指定的寄存器的情况。</span></span><br></pre></td></tr></table></figure><h4 id="改变程序的运行"><a href="#改变程序的运行" class="headerlink" title="改变程序的运行"></a>改变程序的运行</h4><h5 id="修改变量值"><a href="#修改变量值" class="headerlink" title="修改变量值"></a>修改变量值</h5><p>修改程序运行时的变量值</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">print x=4</span><br></pre></td></tr></table></figure><p>如果变量名和gdb参数冲突，可以使用<code>set var</code> 告诉GDB这个是程序的变量名。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">set var width=47</span><br></pre></td></tr></table></figure><p><strong>在有些时候GDB并不会报告这类错误，因此都推荐使用<code>set var</code>的格式修改变量值</strong></p><h5 id="跳转执行"><a href="#跳转执行" class="headerlink" title="跳转执行"></a>跳转执行</h5><p>GDB提供了修改程序的执行顺序的功能，跳转功能，直接跳转到某个语句继续执行</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">jump 行号</span><br><span class="line">jump 代码行的内存地址</span><br></pre></td></tr></table></figure><p><strong>注：跳转并不会改变当前程序栈的内容，所以最好在一个函数内跳转，当你从一个函数跳到另一个函数，函数执行完进行弹栈操作时必然发生错误</strong></p><h5 id="产生信号量"><a href="#产生信号量" class="headerlink" title="产生信号量"></a>产生信号量</h5><p>GDB可以使用<code>singal</code>命令，在断点处由GDB产生一个信号量给被调试程序</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">singal &lt;singal&gt;</span><br></pre></td></tr></table></figure><h5 id="强制函数返回"><a href="#强制函数返回" class="headerlink" title="强制函数返回"></a>强制函数返回</h5><p>如果你的调试断点在某个函数中，并还有语句没有执行完，你可以使用return命令强制函数忽略后面未执行的语句并返回</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">return</span><br><span class="line">return 返回值</span><br></pre></td></tr></table></figure><h5 id="强制调用函数"><a href="#强制调用函数" class="headerlink" title="强制调用函数"></a>强制调用函数</h5><ul><li><p>call命令 </p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">call 函数</span><br><span class="line"><span class="meta">#</span><span class="bash">强制调用函数，并显示返回值，如果返回值时void就不显示</span></span><br></pre></td></tr></table></figure></li><li><p>print 命令</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">print 函数</span><br><span class="line"><span class="meta">#</span><span class="bash">如果函数返回void依旧会显示，并把该值存入历史数据</span></span><br></pre></td></tr></table></figure></li></ul>]]></content>
      
      
      <categories>
          
          <category> 工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> GDB </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/2022/01/06/hello-world/"/>
      <url>/2022/01/06/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
