<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>SQL基本语法</title>
      <link href="/2022/01/11/sql-ji-ben-yu-fa/"/>
      <url>/2022/01/11/sql-ji-ben-yu-fa/</url>
      
        <content type="html"><![CDATA[<blockquote><p>这是我在2020年，大三下学习数据库的笔记，用于自我学习和查询，具体介绍了SQL语句的相关用法，均经过实验可以使用，MYSQL版本5.6.19，客户端Navicat for mysql。<strong>注：个别删除语句没有实践</strong></p></blockquote><span id="more"></span><h4 id="模式介绍"><a href="#模式介绍" class="headerlink" title="模式介绍"></a>模式介绍</h4><p>模式在SQL中大概就是一个数据库的意思，一个MySQL数据库，如果说一张表是一个文件的话，那一个模式就是一个文件夹。</p><p>对模式的操作语句有，创建，删除</p><ul><li><p>创建模式</p></li><li><p>删除模式</p></li></ul><blockquote><p>注：模式的说法只在人大金昌数据库，mysql只有实例，数据库，（表，视图。。。），不予记录了。</p></blockquote><hr><h4 id="表"><a href="#表" class="headerlink" title="表"></a>表</h4><p>表可以说是我们操作MYSQL的基本单位了，表就像是C语言的结构体数组，我们选择每一列的类型，给每一列赋予一个名字。</p><p>创建表：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> Student          </span><br><span class="line">(</span><br><span class="line">     Sno   <span class="type">CHAR</span>(<span class="number">9</span>) <span class="keyword">PRIMARY</span> KEY,        <span class="comment">/* 列级完整性约束条件,Sno是主码*/</span>                  </span><br><span class="line">     Sname <span class="type">CHAR</span>(<span class="number">20</span>) <span class="keyword">UNIQUE</span>,             <span class="comment">/* Sname取唯一值*/</span></span><br><span class="line">     Ssex    <span class="type">CHAR</span>(<span class="number">2</span>),</span><br><span class="line">     Sage   <span class="type">SMALLINT</span>,</span><br><span class="line">     Sdept  <span class="type">CHAR</span>(<span class="number">20</span>)</span><br><span class="line">); </span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span>  Course</span><br><span class="line">(</span><br><span class="line">     Cno    <span class="type">CHAR</span>(<span class="number">4</span>) <span class="keyword">PRIMARY</span> KEY,</span><br><span class="line">     Cname  <span class="type">CHAR</span>(<span class="number">40</span>),            </span><br><span class="line">     Cpno     <span class="type">CHAR</span>(<span class="number">4</span>),                                     </span><br><span class="line">     Ccredit  <span class="type">SMALLINT</span>,</span><br><span class="line">     <span class="keyword">FOREIGN</span> KEY (Cpno) <span class="keyword">REFERENCES</span>  Course(Cno) </span><br><span class="line">); </span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span>  SC</span><br><span class="line">(</span><br><span class="line">    Sno  <span class="type">CHAR</span>(<span class="number">9</span>), </span><br><span class="line">    Cno  <span class="type">CHAR</span>(<span class="number">4</span>),  </span><br><span class="line">    Grade  <span class="type">SMALLINT</span>,</span><br><span class="line">    <span class="keyword">PRIMARY</span> KEY (Sno,Cno),  </span><br><span class="line">    <span class="comment">/* 主码由两个属性构成，必须作为表级完整性进行定义*/</span></span><br><span class="line">    <span class="keyword">FOREIGN</span> KEY (Sno) <span class="keyword">REFERENCES</span> Student(Sno),</span><br><span class="line">    <span class="comment">/* 表级完整性约束条件，Sno是外码，被参照表是Student */</span></span><br><span class="line">    <span class="keyword">FOREIGN</span> KEY (Cno)<span class="keyword">REFERENCES</span> Course(Cno)</span><br><span class="line">    <span class="comment">/* 表级完整性约束条件， Cno是外码，被参照表是Course*/</span></span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>删除表</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">DROP TABLE &lt;表名&gt;［RESTRICT| CASCADE］;</span><br><span class="line">* RESTRICT：删除表是有限制的。</span><br><span class="line">欲删除的基本表不能被其他表的约束所引用</span><br><span class="line">如果存在依赖该表的对象，则此表不能被删除</span><br><span class="line">* CASCADE：删除该表没有限制。</span><br><span class="line">在删除基本表的同时，相关的依赖对象一起删除 </span><br></pre></td></tr></table></figure><p>数据类型有如下：</p><table><thead><tr><th><strong>数据类型</strong></th><th><strong>含义</strong></th></tr></thead><tbody><tr><td>CHAR(n),CHARACTER(n)</td><td>长度为n的定长字符串</td></tr><tr><td>VARCHAR(n),CHARACTERVARYING(n)</td><td>最大长度为n的变长字符串</td></tr><tr><td>CLOB</td><td>字符串大对象</td></tr><tr><td>BLOB</td><td>二进制大对象</td></tr><tr><td>INT，INTEGER</td><td>长整数（4字节）</td></tr><tr><td>SMALLINT</td><td>短整数（2字节）</td></tr><tr><td>BIGINT</td><td>大整数（8字节）</td></tr><tr><td>NUMERIC(p，d)</td><td>定点数，由p位数字（不包括符号、小数点）组成，小数后面有d位数字</td></tr><tr><td>DECIMAL(p, d),  DEC(p, d)</td><td>同NUMERIC</td></tr><tr><td>REAL</td><td>取决于机器精度的单精度浮点数</td></tr><tr><td>DOUBLE  PRECISION</td><td>取决于机器精度的双精度浮点数</td></tr><tr><td>FLOAT(n)</td><td>可选精度的浮点数，精度至少为n位数字</td></tr><tr><td>BOOLEAN</td><td>逻辑布尔量</td></tr><tr><td>DATE</td><td>日期，包含年、月、日，格式为YYYY-MM-DD</td></tr><tr><td>TIME</td><td>时间，包含一日的时、分、秒，格式为HH:MM:SS</td></tr><tr><td>TIMESTAMP</td><td>时间戳类型</td></tr><tr><td>INTERVAL</td><td>时间间隔类型</td></tr></tbody></table><p>修改数据表</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> <span class="operator">&lt;</span>表名<span class="operator">&gt;</span></span><br><span class="line">[ <span class="keyword">ADD</span>[<span class="keyword">COLUMN</span>] <span class="operator">&lt;</span>新列名<span class="operator">&gt;</span> <span class="operator">&lt;</span>数据类型<span class="operator">&gt;</span> [ 完整性约束 ] ]<span class="operator">/</span><span class="operator">/</span>子句用于增加新列、新的列级完整性约束条件和新的表级完整性约束条件</span><br><span class="line">[ <span class="keyword">ADD</span> <span class="operator">&lt;</span>表级完整性约束<span class="operator">&gt;</span>]</span><br><span class="line">[ <span class="keyword">DROP</span> [ <span class="keyword">COLUMN</span> ] <span class="operator">&lt;</span>列名<span class="operator">&gt;</span> [CASCADE<span class="operator">|</span> RESTRICT] ] <span class="operator">/</span><span class="operator">/</span>子句用于删除表中的列</span><br><span class="line"><span class="operator">/</span><span class="operator">/</span>如果指定了CASCADE短语，则自动删除引用了该列的其他对象</span><br><span class="line"><span class="operator">/</span><span class="operator">/</span>如果指定了RESTRICT短语，则如果该列被其他对象引用，关系数据库管理系统将拒绝删除该列</span><br><span class="line">[ <span class="keyword">DROP</span> <span class="keyword">CONSTRAINT</span><span class="operator">&lt;</span>完整性约束名<span class="operator">&gt;</span>[ RESTRICT <span class="operator">|</span> CASCADE ] ]<span class="operator">/</span><span class="operator">/</span><span class="keyword">ALTER</span> <span class="keyword">COLUMN</span>子句用于修改原有的列定义，包括修改列名和数据类型</span><br><span class="line">[<span class="keyword">ALTER</span> <span class="keyword">COLUMN</span> <span class="operator">&lt;</span>列名<span class="operator">&gt;</span><span class="operator">&lt;</span>数据类型<span class="operator">&gt;</span> ] <span class="operator">/</span><span class="operator">/</span><span class="keyword">ALTER</span> <span class="keyword">COLUMN</span>子句用于修改原有的列定义，包括修改列名和数据类型</span><br></pre></td></tr></table></figure><p>案例：向Student表增加“入学时间”列，其数据类型为日期型</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> Student <span class="keyword">ADD</span> S_entrance <span class="type">DATE</span>;</span><br></pre></td></tr></table></figure><p><strong>不管基本表中原来是否已有数据，新增加的列一律为空值</strong> </p><p>案例：将年龄的数据类型由字符型（假设原来的数据类型是字符型）改为整数。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> Student <span class="keyword">ALTER</span> <span class="keyword">COLUMN</span> S_entrance <span class="type">INT</span>;</span><br><span class="line"></span><br><span class="line">出现错误如下：</span><br><span class="line">[<span class="keyword">SQL</span>] <span class="keyword">ALTER</span> <span class="keyword">TABLE</span> student <span class="keyword">ALTER</span> <span class="keyword">COLUMN</span> S_entrance <span class="type">INT</span>;</span><br><span class="line">[Err] <span class="number">1064</span> <span class="operator">-</span> You have an error <span class="keyword">in</span> your <span class="keyword">SQL</span> syntax; <span class="keyword">check</span> the manual that corresponds <span class="keyword">to</span> your MySQL server version <span class="keyword">for</span> the <span class="keyword">right</span> syntax <span class="keyword">to</span> use near <span class="string">&#x27;INT&#x27;</span> <span class="keyword">at</span> line <span class="number">1</span></span><br><span class="line">未解决：</span><br><span class="line">修改为：<span class="keyword">ALTER</span> <span class="keyword">TABLE</span> student modify <span class="keyword">COLUMN</span> S_entrance <span class="type">INT</span>;</span><br><span class="line">板本不同，<span class="keyword">sql</span>语句有差别，我用的版本<span class="keyword">alter</span>需要换成modify</span><br></pre></td></tr></table></figure><p>==如果有数据会怎么样==</p><p>存在数字4，我修改成CHAR（1）,成功，</p><p>存在字符s,y 等，我修改成INT，失败。</p><p>案例：增加课程名称必须取唯一值的约束条件</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> Course <span class="keyword">ADD</span> <span class="keyword">UNIQUE</span>(Cname); </span><br></pre></td></tr></table></figure><h4 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h4><p><strong>建立索引的目的：加快查询速度</strong>（有索引时查询比较快-&gt;WHERE语句）</p><ul><li>顺序文件上的索引</li><li>B+树索引（参见爱课程网3.2节动画《B+树的增删改》）</li><li>散列（hash）索引</li><li>位图索引</li></ul><p>特点：</p><ul><li>B+树索引具有动态平衡的优点 </li><li>HASH索引具有查找速度快的特点</li></ul><p>==关系数据库管理系统自动选择合适的索引作为存取路径，用户不必也不能显式地选择索引==</p><p>语句格式：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">CREATE [UNIQUE] [CLUSTER] INDEX &lt;索引名&gt; ON &lt;表名&gt;(&lt;列名&gt;[&lt;次序&gt;]，[&lt;列名&gt;[&lt;次序&gt;] ]…);</span><br><span class="line">&lt;表名&gt;：要建索引的基本表的名字</span><br><span class="line">索引：可以建立在该表的一列或多列上，各列名之间用逗号分隔</span><br><span class="line">&lt;次序&gt;：指定索引值的排列次序，升序：ASC，降序：DESC。缺省值：ASC</span><br><span class="line">UNIQUE：此索引的每一个索引值只对应唯一的数据记录</span><br><span class="line">CLUSTER：表示要建立的索引是聚簇索引</span><br></pre></td></tr></table></figure><p>==聚簇与否==的介绍：</p><ul><li>聚簇索引：将数据存储与索引放到了一块，找到索引也就找到了数据 </li><li>非聚簇索引：将数据存储于索引分开结构，索引结构的叶子节点指向了数据的对应行，通过key_buffer把索引先缓存到内存中，当需要访问数据时（通过索引访问数据），在内存中直接搜索索引，然后通过索引找到磁盘相应数据，这也就是为什么索引不在key buffer命中时，速度慢的原因</li></ul><p>案例：为学生-课程数据库中的Student，Course，SC三个表建立索引。Student表按学号升序建唯一索引，Course表按课程号升序建唯一索引，SC表按学号升序和课程号降序建唯一索引</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">CREATE UNIQUE INDEX  Stusno ON Student(Sno);</span><br><span class="line">CREATE UNIQUE INDEX  Coucno ON Course(Cno);</span><br><span class="line">CREATE UNIQUE INDEX  SCno ON SC(Sno ASC,Cno DESC);</span><br></pre></td></tr></table></figure><p>运行无误</p><p>修改索引：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ALTER INDEX &lt;旧索引名&gt; RENAME TO &lt;新索引名&gt;</span><br><span class="line">失败，我们的版本是5.6.19，不支持修改索引名</span><br></pre></td></tr></table></figure><p>案例：将SC表的SCno索引名改为SCSno</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ALTER INDEX SCno RENAME TO SCSno</span><br></pre></td></tr></table></figure><p>删除索引</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> tbl_name <span class="keyword">DROP</span> INDEX old_index_name</span><br></pre></td></tr></table></figure><hr><h4 id="查询语句"><a href="#查询语句" class="headerlink" title="查询语句"></a>查询语句</h4><h5 id="查询语句基本模式"><a href="#查询语句基本模式" class="headerlink" title="查询语句基本模式"></a>查询语句基本模式</h5><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">ALL</span><span class="operator">/</span><span class="keyword">DISTINCT</span> 目标表达式</span><br><span class="line"><span class="keyword">FROM</span> 表名或视图名</span><br><span class="line"><span class="keyword">WHERE</span> 条件表达式</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> <span class="operator">&lt;</span>列名<span class="number">1</span><span class="operator">&gt;</span> [ <span class="keyword">HAVING</span> <span class="operator">&lt;</span>条件表达式<span class="operator">&gt;</span> ] </span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> <span class="operator">&lt;</span>列名<span class="number">2</span><span class="operator">&gt;</span> [ <span class="keyword">ASC</span><span class="operator">|</span><span class="keyword">DESC</span> ] </span><br></pre></td></tr></table></figure><ul><li>SELECT子句：指定要显示的属性列</li><li>FROM子句：指定查询对象（基本表或视图）</li><li>WHERE子句：指定查询条件</li><li>GROUP BY子句：对查询结果按指定列的值分组，该属性列值相等的元组为一个组。通常会在每组中作用聚集函数。</li><li>HAVING短语：只有满足指定条件的组才予以输</li><li>ORDER BY子句：对查询结果表按指定列值的升序或降序排序 </li></ul><p>案例1：查询全体学生的学号和姓名（验证）</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> Sno,Sname</span><br><span class="line"><span class="keyword">FROM</span> Student</span><br></pre></td></tr></table></figure><p>案例2：查询全部列(验证)</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> Sno,Sname,Ssex,Sage,Sdept</span><br><span class="line"><span class="keyword">FROM</span> Student；</span><br><span class="line">或者</span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span></span><br><span class="line"><span class="keyword">FROM</span> Student；</span><br></pre></td></tr></table></figure><p>案例3：查询全体学生姓名及出生年月。（由于我们记录的是年龄，而不是出生年，所以我们用当前的年份减去年龄）</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> Sname,<span class="number">2020</span><span class="operator">-</span>Sage</span><br><span class="line"><span class="keyword">FROM</span> Student</span><br></pre></td></tr></table></figure><p>案例4：查询全体学生的姓名、出生年份和所在的院系，要求用小写字母表示系名。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> Sname,<span class="number">2020</span><span class="operator">-</span>Sage,<span class="built_in">LOWER</span>(Sdept)</span><br><span class="line"><span class="keyword">FROM</span> Student</span><br></pre></td></tr></table></figure><p>LOWER()把列的元素换成小写的字母</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">SELECT Sname,&#x27;Year of Birth: &#x27;,2014-Sage,LOWER(Sdept)</span><br><span class="line">FROM Student;</span><br></pre></td></tr></table></figure><p>‘Year of Birth: ‘简介字符串</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">SELECT Sname NAME,&#x27;你的生日&#x27; BIRTH,2020-Sage BIRTHDAY,LOWER(Sdept) DEPARTMENT</span><br><span class="line">FROM Student;</span><br><span class="line">//在列的后面添加名字可以，作为表的表头输出**支持中文**</span><br><span class="line">SELECT Sname 名字,2020-Sage 出生年份,LOWER(Sdept) 专业</span><br><span class="line">FROM Student;</span><br></pre></td></tr></table></figure><p><img src="/image/image-20200307125917603.png" alt="image-20200307125917603"></p><p>取消重复的行</p><ul><li>SELECT ALL/DISTINCT 目标表达式</li><li>如果没有指定DISTINCT关键词，则缺省为ALL </li></ul><p>eg:</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> Sno   <span class="keyword">FROM</span> SC;</span><br><span class="line">等价于：</span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">ALL</span>  Sno  <span class="keyword">FROM</span> SC;</span><br></pre></td></tr></table></figure><p>去掉重复行的话，就要指定关键字DISTINCT</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">DISTINCT</span> Sno</span><br><span class="line"><span class="keyword">FROM</span> SC; </span><br></pre></td></tr></table></figure><h5 id="WHERE关键字"><a href="#WHERE关键字" class="headerlink" title="WHERE关键字"></a>WHERE关键字</h5><p>该关键字是用来筛选的，在WHERE后面加条件表达式，选出符合表达式的内容</p><p><strong>注：WHERE后面的条件会应用索引，有索引的查询速度快，对于逻辑表达式来说，AND会的判断是按顺序的，所以请优先把有索引的判断条件放在前面，OR则没有影响</strong></p><table><thead><tr><th>查 询  条 件</th><th>谓  词</th></tr></thead><tbody><tr><td>比  较</td><td>=, &gt;, &lt;, &gt;=, &lt;=, !=, &lt;&gt;, !&gt;, !&lt;; NOT+上述比较运算符</td></tr><tr><td>确定范围</td><td>BETWEEN  AND, NOT  BETWEEN AND</td></tr><tr><td>确定集合</td><td>IN, NOT  IN</td></tr><tr><td>字符匹配</td><td>LIKE, NOT  LIKE</td></tr><tr><td>空  值</td><td>IS  NULL, IS  NOT NULL</td></tr><tr><td>多重条件（逻辑运算）</td><td>AND, OR, NOT</td></tr></tbody></table><p>案例5：查询计算机科学系全体学生的名单</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">SELECT Sname</span><br><span class="line">FROM student</span><br><span class="line">WHERE Sdept=&#x27;CS&#x27;</span><br></pre></td></tr></table></figure><p>案例6：查询年龄在20岁以下的学生姓名</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">SELECT Sname</span><br><span class="line">FROM student</span><br><span class="line">WHERE Sage&lt;20;</span><br></pre></td></tr></table></figure><p>案例7：查询考试成绩不及格的所有学生的学号</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">SELECT DISTINCT Sno</span><br><span class="line">FROM SC</span><br><span class="line">WHERE Grade&lt;60;</span><br></pre></td></tr></table></figure><h6 id="范围查询"><a href="#范围查询" class="headerlink" title="范围查询"></a>范围查询</h6><p>案例8：查询年龄在20-23岁之间的学生的姓名、系别和年龄</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">SELECT Sname,Sdept,Sage</span><br><span class="line">FROM Student</span><br><span class="line">WHERE Sage BETWEEN 20 AND 23;</span><br></pre></td></tr></table></figure><p>案例9：查询年龄不在20~23岁之间的学生姓名、系别和年龄</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> Sname,Sdept,Sage</span><br><span class="line"><span class="keyword">FROM</span> Student</span><br><span class="line"><span class="keyword">WHERE</span> Sage <span class="keyword">NOT</span> <span class="keyword">BETWEEN</span> <span class="number">20</span> <span class="keyword">AND</span> <span class="number">23</span>;</span><br></pre></td></tr></table></figure><p>案例10：查询计算机科学系（CS）、数学系（MA）和信息系（IS）学生的姓名和性别。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">SELECT Sname,Ssex</span><br><span class="line">FROM Student</span><br><span class="line">WHERE Sdept IN(&#x27;CS&#x27;,&#x27;MA&#x27;,&#x27;IS&#x27;);</span><br></pre></td></tr></table></figure><h6 id="字符串匹配"><a href="#字符串匹配" class="headerlink" title="字符串匹配"></a>字符串匹配</h6><p>关键字： LIKE</p><ul><li>% （百分号）  代表任意长度（长度可以为0）的字符串，例如a%b表示以a开头，以b结尾的任意长度的字符串</li><li>_ （下横线）  代表任意单个字符，例如a_b表示以a开头，以b结尾的长度为3的任意字符串</li></ul><p>案例11：查询学号为201215121的学生的详细情况。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">SELECT *</span><br><span class="line">FROM Student</span><br><span class="line">WHERE Sno LIKE &#x27;201215121&#x27;</span><br></pre></td></tr></table></figure><p>案例12：查询所有刘性学生的姓名，学号和性别</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">SELECT Sname,Sno,Ssex</span><br><span class="line">FROM Student</span><br><span class="line">WHERE Sname LIKE &#x27;刘%&#x27;;</span><br><span class="line">输出如下:</span><br><span class="line">刘晨201215122女</span><br></pre></td></tr></table></figure><p>案例13：查询姓欧阳的且全名为三个汉字的学生的信息</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">SELECT *</span><br><span class="line">FROM Student</span><br><span class="line">WHERE Sname LIKE &#x27;欧阳_&#x27;;</span><br><span class="line">由于我的表格没有姓欧阳的人，输出为空，为了验证是否正确，我在表格加入欧阳锋和欧阳娜娜两个人</span><br><span class="line">201215126欧阳锋男27CSs</span><br><span class="line">201215127欧阳娜娜女23CSs</span><br><span class="line">下面运行我的代码：</span><br><span class="line">成功找到欧阳锋：</span><br><span class="line">201215126欧阳锋男27CSs</span><br></pre></td></tr></table></figure><p>转码字符和转义字符的相关用法</p><ol><li>什么是转义字符？//转义字符是语言内定的一些符号比如，%，_等，具有特定的含义，特殊的功能？</li><li>什么是转码字符？有什么用？//我们在现实使用中有可能也要用到这些字符，转码字符就是可以把转义字符变成普通字符的一个关键字</li></ol><p>案例14：查询DB_Design课程的课程号和学分。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="operator">/</span><span class="operator">/</span>我们的课程名中存在下划线，但是在<span class="keyword">SQL</span>语句中，下划线会被定义成通配符，因此我们需要定义转义字符，转义字符的关键字为<span class="keyword">ESCAPE</span> <span class="string">&#x27;/&#x27;</span>，这里的<span class="operator">/</span>就成功被定义成了转义字符</span><br><span class="line"><span class="keyword">SELECT</span> Cno,Ccredit</span><br><span class="line"><span class="keyword">FROM</span> Course</span><br><span class="line"><span class="keyword">WHERE</span> Cname <span class="keyword">LIKE</span> <span class="string">&#x27;DB/_Design&#x27;</span> <span class="keyword">ESCAPE</span> <span class="string">&#x27;/&#x27;</span></span><br></pre></td></tr></table></figure><p>案例15：查询以”DB_”开头，且倒数第3个字符为 i的课程的详细情况。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span></span><br><span class="line"><span class="keyword">FROM</span> Course</span><br><span class="line"><span class="keyword">WHERE</span> Cname <span class="keyword">LIKE</span> <span class="string">&#x27;DB/_%i__&#x27;</span> <span class="keyword">ESCAPE</span> <span class="string">&#x27;/&#x27;</span></span><br></pre></td></tr></table></figure><h6 id="空值的查询"><a href="#空值的查询" class="headerlink" title="空值的查询"></a>空值的查询</h6><p>关键字： IS NULL 或 IS NOT NULL  <strong>“IS” 不能用 “=” 代替</strong></p><p>案例：某些的学号和相应的课程号。学生选修课程后没有参加考试，所以有选课记录，但没 有考试成绩。查询缺少成绩的学生</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span></span><br><span class="line"><span class="keyword">FROM</span> SC</span><br><span class="line"><span class="keyword">WHERE</span> Grade <span class="keyword">IS</span> <span class="keyword">NULL</span></span><br></pre></td></tr></table></figure><h6 id="多重条件查询"><a href="#多重条件查询" class="headerlink" title="多重条件查询"></a>多重条件查询</h6><p>逻辑运算符：AND 和 OR 来连接多个条件表达式 <strong>AND的优先级高，但可以用（）改变优先级</strong></p><p>案例：查询计算机系，年龄在20岁以下的学生的姓名</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> Sname</span><br><span class="line"><span class="keyword">FROM</span> Student</span><br><span class="line"><span class="keyword">WHERE</span> Sage <span class="operator">&lt;</span> <span class="number">20</span> <span class="keyword">AND</span> Sdept<span class="operator">=</span><span class="string">&#x27;CS&#x27;</span>;</span><br></pre></td></tr></table></figure><p>案例：查询计算机科学系（CS）、数学系（MA）和信息系（IS）学生的姓名和性别。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">使用<span class="keyword">IN</span>关键字</span><br><span class="line"><span class="keyword">SELECT</span> Sname,Ssex</span><br><span class="line"><span class="keyword">FROM</span> Student</span><br><span class="line"><span class="keyword">WHERE</span> Sdept <span class="keyword">IN</span>(<span class="string">&#x27;CS&#x27;</span>,<span class="string">&#x27;MA&#x27;</span>,<span class="string">&#x27;IS&#x27;</span>);</span><br><span class="line">使用逻辑运算符</span><br><span class="line"><span class="keyword">SELECT</span> Sname,Ssex</span><br><span class="line"><span class="keyword">FROM</span> Student</span><br><span class="line"><span class="keyword">WHERE</span> Sdept<span class="operator">=</span><span class="string">&#x27;CS&#x27;</span> <span class="keyword">OR</span> Sdept<span class="operator">=</span><span class="string">&#x27;MA&#x27;</span> <span class="keyword">OR</span> Sdept<span class="operator">=</span><span class="string">&#x27;IS&#x27;</span>;</span><br></pre></td></tr></table></figure><h5 id="排列"><a href="#排列" class="headerlink" title="排列"></a>排列</h5><p>有时候我们需要用到排列，SQL提供了<code>ORDER BY</code>关键字</p><ul><li>可以按照一个或者多个属性列排序</li><li>升序：ASC；降序：DESC；缺省值则为升序</li><li>对于空值，排序时显示的次序由具体系统实现来决定</li></ul><p>案例：查询选修了3号课程的学生的学号及其成绩，查询结果按分数降序排列。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> Sno,Grade</span><br><span class="line"><span class="keyword">FROM</span> SC</span><br><span class="line"><span class="keyword">WHERE</span> Cno<span class="operator">=</span><span class="string">&#x27;3&#x27;</span></span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> Grade <span class="keyword">DESC</span>;</span><br><span class="line">疑问：匹配时我直接用整数为什么也可以</span><br><span class="line"><span class="keyword">SELECT</span> Sno,Grade</span><br><span class="line"><span class="keyword">FROM</span> SC</span><br><span class="line"><span class="keyword">WHERE</span> Cno<span class="operator">=</span><span class="number">3</span></span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> Grade <span class="keyword">DESC</span>;</span><br></pre></td></tr></table></figure><h5 id="聚集函数"><a href="#聚集函数" class="headerlink" title="聚集函数"></a>聚集函数</h5><ul><li>统计元组个数<code>COUNT(*)</code></li><li>统计一列中值的个数<code>COUNT([DISTINCT|ALL] &lt;列名&gt;)</code></li><li>计算一列值的总和<code>SUM([DISTINCT|ALL] &lt;列名&gt;)</code></li><li>计算一列值的平均值<code>AVG([DISTINCT|ALL] &lt;列名&gt;)</code></li><li>求一列中的最大值<code>MAX([DISTINCT|ALL] &lt;列名&gt;);MIN([DISTINCT|ALL] &lt;列名&gt;)</code></li></ul><p>案例：查询学生总数</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="built_in">COUNT</span>(<span class="operator">*</span>)</span><br><span class="line"><span class="keyword">FROM</span> Student;</span><br></pre></td></tr></table></figure><p>案例：查询选修了课程的学生人数</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="built_in">COUNT</span>(<span class="keyword">DISTINCT</span> Sno)</span><br><span class="line"><span class="keyword">FROM</span> SC;</span><br></pre></td></tr></table></figure><p>案例：计算一号课程的学生的平均成绩</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">SELECT AVG(Grade)</span><br><span class="line">FROM SC</span><br><span class="line">WHERE Cno=&#x27;1&#x27;;</span><br></pre></td></tr></table></figure><p>案例：查询选修1号课程的学生最高分数。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">SELECT MAX(Grade)</span><br><span class="line">FROM SC</span><br><span class="line">WHERE Cno=&#x27;1&#x27;;</span><br></pre></td></tr></table></figure><p>案例：查询学生201215121选修课程的总学分数。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">SELECT SUM(Ccredit)</span><br><span class="line">FROM SC,Course</span><br><span class="line">WHERE Sno=&#x27;201215121&#x27;AND SC.Cno=Course.Cno</span><br></pre></td></tr></table></figure><p>GROUP BY 语句：细化聚集函数的作用对象</p><ul><li>如果未对查询结果分组，聚集函数将作用于整个查询结果</li><li>对查询结果分组后，聚集函数将分别作用于每个组 </li><li>按指定的一列或多列值分组，值相等的为一组</li></ul><p>案例：求各个课程号及相应的选课人数</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">这里对查询结果分组，这样的话聚集函数作用于每个组</span><br><span class="line">SELECT Cno,COUNT(Sno)</span><br><span class="line">FROM SC</span><br><span class="line">GROUP BY Cno;</span><br><span class="line">输出结果为：</span><br><span class="line">11</span><br><span class="line">23</span><br><span class="line">32</span><br><span class="line">51</span><br></pre></td></tr></table></figure><p>案例：查询选修了三门以上课程的学生学号</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">SELECT Sno</span><br><span class="line">FROM  SC</span><br><span class="line">GROUP BY Sno</span><br><span class="line">HAVING  COUNT(*) &gt;3;      </span><br></pre></td></tr></table></figure><p>案例：查询平均成绩大于等于90分的学生学号和平均成绩</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">下面的语句是不对的：</span><br><span class="line">SELECT Sno, AVG(Grade)</span><br><span class="line">FROM  SC</span><br><span class="line">WHERE AVG(Grade)&gt;=90</span><br><span class="line">GROUP BY Sno;</span><br><span class="line">因为WHERE子句中是不能用聚集函数作为条件表达式</span><br><span class="line">正确的查询语句应该是：</span><br><span class="line">SELECT  Sno, AVG(Grade)</span><br><span class="line">FROM  SC</span><br><span class="line">GROUP BY Sno</span><br><span class="line">HAVING AVG(Grade)&gt;=90;</span><br></pre></td></tr></table></figure><ul><li>HAVING短语与WHERE子句的区别：作用对象不同，WHERE子句作用于基表或视图，从中选择满足条件的元组，HAVING短语作用于组，从中选择满足条件的组。</li></ul><h5 id="连接查询"><a href="#连接查询" class="headerlink" title="连接查询"></a>连接查询</h5><p>故名知意，涉及两个或两个以上的表的查询</p><h6 id="等值与非等值连接查询"><a href="#等值与非等值连接查询" class="headerlink" title="等值与非等值连接查询"></a>等值与非等值连接查询</h6><ul><li>等值连接：使用连接运算符=</li></ul><p>案例：查询每个学生及其选修课程的情况</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span>  Student.<span class="operator">*</span>, SC.<span class="operator">*</span></span><br><span class="line"><span class="keyword">FROM</span>     Student, SC</span><br><span class="line"><span class="keyword">WHERE</span>  Student.Sno <span class="operator">=</span> SC.Sno;</span><br></pre></td></tr></table></figure><p>执行过程(体现不出关系数据库关系的？那还要关系做什么)</p><blockquote><p>（1）嵌套循环法（NESTED-LOOP）</p><p>首先在表1中找到第一个元组，然后从头开始扫描表2，逐一查找满足连接件的元组，找到后就将表1中的第一个元组与该元组拼接起来，形成结果表中一个元组。<br>        表2全部查找完后，再找表1中第二个元组，然后再从头开始扫描表2，逐一查找满足连接条件的元组，找到后就将表1中的第二个元组与该元组拼接起来，形成结果表中一个元组。<br>        重复上述操作，直到表1中的全部元组都处理完毕</p><p>（2）排序合并法（SORT-MERGE）</p><p>常用于=连接<br>        首先按连接属性对表1和表2排序<br>        对表1的第一个元组，从头开始扫描表2，顺序查找满足连接条件的元组，找到后就将表1中的第一个元组与该元组拼接起来，形成结果表中一个元组。当遇到表2中第一条大于表1连接字段值的元组时，对表2的查询不再继续</p><p>找到表1的第二条元组，然后从刚才的中断点处继续顺序扫描表2，查找满足连接条件的元组，找到后就将表1中的第一个元组与该元组拼接起来，形成结果表中一个元组。直接遇到表2中大于表1连接字段值的元组时，对表2的查询不再继续<br>        重复上述操作，直到表1或表2中的全部元组都处理完毕为止 </p><p>（3）索引连接（INDEX-JOIN）</p><p>对表2按连接字段建立索引<br>        对表1中的每个元组，依次根据其连接字段值查询表2的索引，从中找到满足条件的元组，找到后就将表1中的第一个元组与该元组拼接起来，形成结果表中一个元组</p></blockquote><p>自然连接</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">[例 <span class="number">3.50</span>]  对[例 <span class="number">3.49</span>]用自然连接完成。</span><br><span class="line"> <span class="keyword">SELECT</span>  Student.Sno,Sname,Ssex,Sage,Sdept,Cno,Grade</span><br><span class="line"> <span class="keyword">FROM</span>     Student,SC</span><br><span class="line"> <span class="keyword">WHERE</span>  Student.Sno <span class="operator">=</span> SC.Sno;</span><br><span class="line">[例 <span class="number">3.49</span>]  查询每个学生及其选修课程的情况</span><br><span class="line"><span class="keyword">SELECT</span>  Student.<span class="operator">*</span>, SC.<span class="operator">*</span></span><br><span class="line"><span class="keyword">FROM</span>     Student, SC</span><br><span class="line"><span class="keyword">WHERE</span>  Student.Sno <span class="operator">=</span> SC.Sno;</span><br><span class="line"><span class="number">3.49</span>自己加进来对比的</span><br></pre></td></tr></table></figure><p>1、自然连接一定是等值连接，等值连接不一定是自然连接。</p><p>2、等值连接不把重复的属性去掉，自然连接要把重复的属性去掉。</p><p>SQL语句的不同就是 在于 例3.50里没有选择SC里的sno那一列</p><p>连接和判断同时存在的情况也是有的，比如</p><p>案例：查询选修2号课程且成绩在90分以上的所有学生的学号和姓名。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> Student.Sno, Sname</span><br><span class="line"><span class="keyword">FROM</span>     Student, SC</span><br><span class="line"><span class="keyword">WHERE</span>  Student.Sno<span class="operator">=</span>SC.Sno  <span class="keyword">AND</span>                   </span><br><span class="line">SC.Cno<span class="operator">=</span><span class="string">&#x27; 2 &#x27;</span> <span class="keyword">AND</span> SC.Grade<span class="operator">&gt;</span><span class="number">90</span>;</span><br></pre></td></tr></table></figure><p>执行过程：</p><p>​    先从SC中挑选出Cno=’2’并且Grade&gt;90的元组形成一个中间关系<br>​            再和Student中满足连接条件的元组进行连接得到最终的结果关系</p><h6 id="自身连接"><a href="#自身连接" class="headerlink" title="自身连接"></a>自身连接</h6><p>自己和自己连接</p><p>需要给表起别名以区别</p><p>由于所有属性名都是同名属性，因此必须使用别名前缀</p><p>案例：查询每一门课的间接先修课（即先修课的先修课）</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span>  FIRST.Cno, SECOND.Cpno</span><br><span class="line"><span class="keyword">FROM</span>  Course  <span class="keyword">FIRST</span>, Course  <span class="keyword">SECOND</span></span><br><span class="line"><span class="keyword">WHERE</span> FIRST.Cpno <span class="operator">=</span> SECOND.Cno;</span><br></pre></td></tr></table></figure><h6 id="外连接"><a href="#外连接" class="headerlink" title="外连接"></a>外连接</h6><p>区别：普通连接操作只输出满足连接条件的元组,外连接操作以指定表为连接主体，将主体表中不满足连接条件的元组一并输出。</p><p> 左外连接：列出左边关系中所有的元组<br>         右外连接：列出右边关系中所有的元组</p><p> 案例：改写[例 3.49]</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> Student.Sno,Sname,Ssex,Sage,Sdept,Cno,Grade</span><br><span class="line"><span class="keyword">FROM</span>  Student  <span class="keyword">LEFT</span> <span class="keyword">OUTER</span> <span class="keyword">JOIN</span> SC </span><br><span class="line"><span class="keyword">ON</span>(Student.Sno<span class="operator">=</span>SC.Sno); </span><br></pre></td></tr></table></figure><h6 id="多表连接"><a href="#多表连接" class="headerlink" title="多表连接"></a>多表连接</h6><p>两个以上的表进行连接</p><p>案例：查询每个学生的学号、姓名、选修的课程名及成绩</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> Student.Sno, Sname, Cname, Grade</span><br><span class="line"><span class="keyword">FROM</span>    Student, SC, Course    <span class="comment">/*多表连接*/</span></span><br><span class="line"><span class="keyword">WHERE</span> Student.Sno <span class="operator">=</span> SC.Sno </span><br><span class="line"><span class="keyword">AND</span> SC.Cno <span class="operator">=</span> Course.Cno;</span><br></pre></td></tr></table></figure><h5 id="嵌套查询"><a href="#嵌套查询" class="headerlink" title="嵌套查询"></a>嵌套查询</h5><h4 id="插入数据"><a href="#插入数据" class="headerlink" title="插入数据"></a>插入数据</h4><p>语句格式：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">INSERT</span></span><br><span class="line"><span class="keyword">INTO</span> 表名（列名）</span><br><span class="line"><span class="keyword">VALUES</span> （数据）</span><br></pre></td></tr></table></figure><ul><li><p>INTO </p><ul><li>指定要插入数据的表名及属性列</li><li>属性列的顺序可与表定义中的顺序不一致</li><li>没有指定属性列：表示要插入的是一条完整的元组，且属性列属性与表定义中的顺序一致</li><li>指定部分属性列：插入的元组在其余属性列上取空值</li></ul></li><li><p>VALUE</p><ul><li>提供的值必须与INTO子句匹配，值的个数和值的类型</li></ul></li></ul><p>案例：插入一条选课记录（ ‘200215128’,’1 ‘）</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">INSERT</span></span><br><span class="line"><span class="keyword">INTO</span> SC(Sno,Cno)</span><br><span class="line"><span class="keyword">VALUES</span> (<span class="string">&#x27;201215128 &#x27;</span>,<span class="string">&#x27;1&#x27;</span>);</span><br><span class="line">或者：</span><br><span class="line"><span class="keyword">INSERT</span></span><br><span class="line"><span class="keyword">INTO</span> SC</span><br><span class="line"><span class="keyword">VALUES</span> (<span class="string">&#x27; 201215128 &#x27;</span>,<span class="string">&#x27;1&#x27;</span>,<span class="keyword">NULL</span>);</span><br></pre></td></tr></table></figure><p>插入子查询数据</p><p>INSERT<br>        INTO &lt;表名&gt;  [(&lt;属性列1&gt; [,&lt;属性列2&gt;…  )]<br>        子查询;</p><p><strong>SELECT子句目标列必须与INTO子句匹配</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">INSERT</span></span><br><span class="line"><span class="keyword">INTO</span>  Dept_age(Sdept,Avg_age)</span><br><span class="line"><span class="keyword">SELECT</span>  Sdept,<span class="built_in">AVG</span>(Sage)</span><br><span class="line"><span class="keyword">FROM</span>  Student</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> Sdept;</span><br></pre></td></tr></table></figure><p><img src="/image/image-20200318232659266.png" alt="image-20200318232659266"></p><p><strong>实体的完整性和参照完整性是什么</strong></p><h4 id="修改数据"><a href="#修改数据" class="headerlink" title="修改数据"></a>修改数据</h4><p>语句格式：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">UPDATA 表名</span><br><span class="line"><span class="keyword">SET</span> 列名<span class="operator">=</span>表达式，列名<span class="operator">=</span>表达式...</span><br><span class="line"><span class="keyword">WHERE</span> 条件</span><br></pre></td></tr></table></figure><p><strong>功能</strong>：修改指定表中满足WHERE子句条件的元组，SET子句给出&lt;表达式&gt;的值用于取代相应的属性列，如果省略WHERE子句，表示要修改表中的所有元组</p><p>案例：将学生201215121的年龄改为22岁</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">UPDATA Student</span><br><span class="line"><span class="keyword">SET</span> Sage<span class="operator">=</span><span class="number">22</span></span><br><span class="line"><span class="keyword">WHERE</span> Sno<span class="operator">=</span><span class="string">&#x27;201215121&#x27;</span></span><br></pre></td></tr></table></figure><p>案例：将计算机科学系全体学生的成绩置零</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">UPDATA SC</span><br><span class="line"><span class="keyword">SET</span> Grade<span class="operator">=</span><span class="number">0</span></span><br><span class="line"><span class="keyword">WHERE</span> Sno <span class="keyword">IN</span></span><br><span class="line">(<span class="keyword">SELECT</span> Sno</span><br><span class="line"><span class="keyword">FROM</span> Student</span><br><span class="line"><span class="keyword">WHERE</span> Sdept<span class="operator">=</span><span class="string">&#x27;CS&#x27;</span>);</span><br></pre></td></tr></table></figure><h4 id="删除数据"><a href="#删除数据" class="headerlink" title="删除数据"></a>删除数据</h4><p>删除指定表中满足WHERE子句条件的元组，语句格式</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">DELETE</span></span><br><span class="line"><span class="keyword">FROM</span> 表名</span><br><span class="line"><span class="keyword">WHERE</span> 条件</span><br></pre></td></tr></table></figure><p>案例：删除学号为201215128的学生记录</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">DELETE</span></span><br><span class="line"><span class="keyword">FROM</span> Student</span><br><span class="line"><span class="keyword">WHERE</span> Sno<span class="operator">=</span><span class="string">&#x27;201215128&#x27;</span></span><br></pre></td></tr></table></figure><p>案例：删除计算机科学系所有学生的选课记录</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">DELETE</span></span><br><span class="line"><span class="keyword">FROM</span>  SC</span><br><span class="line"><span class="keyword">WHERE</span>  Sno  <span class="keyword">IN</span></span><br><span class="line">(SELETE  Sno</span><br><span class="line"><span class="keyword">FROM</span>   Student</span><br><span class="line"><span class="keyword">WHERE</span>  Sdept<span class="operator">=</span> <span class="string">&#x27;CS&#x27;</span>) ;</span><br></pre></td></tr></table></figure><h4 id="空值"><a href="#空值" class="headerlink" title="空值"></a>空值</h4><p>空值：NULL</p><p>没有具体的数据，还没填的数据等各种情况导致的空值</p><p>判断空值</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">IS</span> <span class="keyword">NULL</span></span><br><span class="line"><span class="keyword">IS</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span></span><br></pre></td></tr></table></figure><p>不能取空值的情况</p><ul><li>有NOT NULL约束条件的不能取空值</li><li>加了UNIQUE限制的属性不能取空值</li><li>码属性不能取空值（主键）</li></ul><p>空值的运算</p><ul><li>空值与另一个值（包括另一个空值）的算术运算的结果为空值</li><li>空值与另一个值（包括另一个空值）的比较运算的结果为UNKNOWN。有UNKNOWN后，传统二值（TRUE，FALSE）逻辑就扩展成了三值逻辑</li></ul><h4 id="视图"><a href="#视图" class="headerlink" title="视图"></a>视图</h4><p>什么是视图？</p><p>答：视图是定义好的查询结构，类似于一个定义好的查询函数，每次需要查询相同的数据时方便调用。</p><p>建立视图：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">VIEW</span> 视图名 列名</span><br><span class="line"><span class="keyword">AS</span> 子查询</span><br><span class="line"><span class="keyword">WITH</span>  <span class="keyword">CHECK</span>  OPTION</span><br></pre></td></tr></table></figure><p>WITH CHECK OPTION:<br>        答：对视图进行UPDATE，INSERT和DELETE操作时要保证更新、插入或删除的行满足视图定义中的谓词条件（即子查询中的条件表达式）</p><p>子查询可以是任意的SELECT语句，是否可以含有ORDER BY子句和DISTINCT短语，则决定具体系统的实现</p><p>案例：建立信息系学生的视图。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">VIEW</span> IS_Student</span><br><span class="line"><span class="keyword">AS</span> </span><br><span class="line"><span class="keyword">SELECT</span> Sno,Sname,Sage</span><br><span class="line"><span class="keyword">FROM</span>     Student</span><br><span class="line"><span class="keyword">WHERE</span>  Sdept<span class="operator">=</span> <span class="string">&#x27;IS&#x27;</span>;</span><br></pre></td></tr></table></figure><p>案例：建立信息系学生的视图，并要求进行修改和插入操作时仍需保证该视图只有信息系的学生 。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">VIEW</span> IS_Student</span><br><span class="line"><span class="keyword">AS</span> </span><br><span class="line"><span class="keyword">SELECT</span> Sno,Sname,Sage,Sdept</span><br><span class="line"><span class="keyword">FROM</span>  Student</span><br><span class="line"><span class="keyword">WHERE</span>  Sdept<span class="operator">=</span> <span class="string">&#x27;IS&#x27;</span></span><br><span class="line"><span class="keyword">WITH</span> <span class="keyword">CHECK</span> OPTION;</span><br></pre></td></tr></table></figure><p>对视图插入数据，修改数据，删除数据</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">插入数据</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> is_student(sno,sname,sage,sDept) <span class="keyword">values</span>(<span class="string">&#x27;201215138&#x27;</span>,<span class="string">&#x27;李思&#x27;</span>,<span class="number">34</span>,<span class="string">&#x27;IS&#x27;</span>)</span><br><span class="line">修改数据(无用)，<span class="number">201215121</span>，并不是信息系的学生，无法通过该视图修改</span><br><span class="line">update is_student <span class="keyword">set</span> sname<span class="operator">=</span><span class="string">&#x27;李勇1&#x27;</span> <span class="keyword">where</span> sno<span class="operator">=</span><span class="string">&#x27;201215121&#x27;</span></span><br><span class="line">删除数据(无用)，同上</span><br><span class="line"><span class="keyword">delete</span> <span class="keyword">from</span> is_student <span class="keyword">where</span> sno<span class="operator">=</span><span class="string">&#x27;201215121&#x27;</span></span><br></pre></td></tr></table></figure><p>基于多个基表的视图</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">VIEW</span> IS_S1(Sno,Sname,Grade)</span><br><span class="line"><span class="keyword">AS</span> </span><br><span class="line"><span class="keyword">SELECT</span> Student.Sno,Sname,Grade</span><br><span class="line"><span class="keyword">FROM</span>  Student,SC</span><br><span class="line"><span class="keyword">WHERE</span>  Sdept<span class="operator">=</span> <span class="string">&#x27;IS&#x27;</span> <span class="keyword">AND</span> Student.Sno<span class="operator">=</span>SC.Sno <span class="keyword">AND</span> SC.Cno<span class="operator">=</span> <span class="string">&#x27;1&#x27;</span>;</span><br></pre></td></tr></table></figure><p>基于视图的视图</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">VIEW</span> IS_S2</span><br><span class="line"><span class="keyword">AS</span></span><br><span class="line"><span class="keyword">SELECT</span> Sno,Sname,Grade</span><br><span class="line"><span class="keyword">FROM</span>  IS_S1</span><br><span class="line"><span class="keyword">WHERE</span>  Grade<span class="operator">&gt;=</span><span class="number">90</span>;</span><br></pre></td></tr></table></figure><p>案例：建立一个反应出生年月的视图</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span>  <span class="keyword">VIEW</span> BT_S(Sno,Sname,Sbirth)</span><br><span class="line"><span class="keyword">AS</span> </span><br><span class="line"><span class="keyword">SELECT</span> Sno,Sname,<span class="number">2020</span><span class="operator">-</span>Sage</span><br><span class="line"><span class="keyword">FROM</span>  Student;</span><br></pre></td></tr></table></figure><p>删除视图</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">DROP</span>  <span class="keyword">VIEW</span>  <span class="operator">&lt;</span>视图名<span class="operator">&gt;</span>[CASCADE];</span><br><span class="line">#如果该视图上还导出了其他视图，使用CASCADE级联删除语句，把该视图和由它导出的所有视图一起删除 </span><br><span class="line">#删除基表时，由该基表导出的所有视图定义都必须显式地使用<span class="keyword">DROP</span> <span class="keyword">VIEW</span>语句删除 </span><br></pre></td></tr></table></figure><p><strong>查询视图与查询基本表相同</strong></p><p><a href="https://blog.csdn.net/chengjianghao/article/details/86477207">视图</a></p>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据库 </tag>
            
            <tag> SQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>多线程学习笔记</title>
      <link href="/2022/01/11/duo-xian-cheng-bi-ji/"/>
      <url>/2022/01/11/duo-xian-cheng-bi-ji/</url>
      
        <content type="html"><![CDATA[<blockquote><p>2020年实习时，时间充裕，导师让我学习多线程相关知识时记录的相关笔记，使用教材《UNIX环境高级编程》</p></blockquote><span id="more"></span><h2 id="线程创建"><a href="#线程创建" class="headerlink" title="线程创建"></a>线程创建</h2><h3 id="线程ID"><a href="#线程ID" class="headerlink" title="线程ID"></a>线程ID</h3><p>线程ID类型是<code>pthread_t</code>，因此不可以直接使用整数判断，下面给出判断函数</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_equal</span><span class="params">(tid1,tid2)</span></span>;</span><br><span class="line"><span class="comment">//相等返回非0，不相等返回0</span></span><br></pre></td></tr></table></figure><p>以及获取自身线程ID的函数</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">pthread_t</span> <span class="title">pthread_self</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br></pre></td></tr></table></figure><h3 id="线程创建-1"><a href="#线程创建-1" class="headerlink" title="线程创建"></a>线程创建</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="keyword">pthread_t</span> ntid;<span class="comment">//线程id变量</span></span><br><span class="line"><span class="keyword">int</span> err=<span class="built_in">pthread_create</span>(线程ID地址，线程属性，线程运行函数，函数参数）</span><br><span class="line"><span class="keyword">if</span>(err!=<span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;cam&#x27;t create thread&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="线程终止"><a href="#线程终止" class="headerlink" title="线程终止"></a>线程终止</h2><h3 id="线程退出"><a href="#线程退出" class="headerlink" title="线程退出"></a>线程退出</h3><p>任意一线程调用exit函数都会将<strong>整个进程</strong>结束掉，如果想要结束某个线程，而不终止整个进程的话有以下三种办法：</p><ul><li>返回 <code>return</code></li><li>被同一进程的其他线程取消<code>int pthread_cancel(线程ID)</code></li><li>调用<code>pthread_exit</code></li></ul><h3 id="获取已结束线程的返回码"><a href="#获取已结束线程的返回码" class="headerlink" title="获取已结束线程的返回码"></a>获取已结束线程的返回码</h3><p>当一个线程被<code>return</code> 或者<code>pthread_exit</code>结束掉时，我们可使用<code>pthread_join</code>函数去获取已结束线程的返回码。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_join</span><span class="params">(已结束线程ID，保存返回码的二重指针)</span></span>;</span><br><span class="line"><span class="comment">//返回的是一个指针，要获取指针的值，把获取的指针保存在指针中，所以是二重指针</span></span><br><span class="line"><span class="comment">//调用时输入的是指针的地址</span></span><br></pre></td></tr></table></figure><p><strong>当已结束的线程被<code>pthread_join</code>调用时，会把线程置于分离状态，这样资源就可以恢复</strong></p><h3 id="线程清理处理程序"><a href="#线程清理处理程序" class="headerlink" title="线程清理处理程序"></a>线程清理处理程序</h3><p>线程可以安排在退出时要执行的操作，一个线程可以安排多个处理程序，但是安排在<strong>栈</strong>中，注意调用顺序<strong>后进先出</strong>。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">pthread_cleanup_push</span><span class="params">(处理函数，参数)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">pthread_cleanup_pop</span><span class="params">(参数)</span></span>;<span class="comment">//参数为0时，清理函数将不被调用</span></span><br></pre></td></tr></table></figure><p>注：<strong>return的退出不会触发清理程序</strong>，<code>pthread_exit</code>会触发。当不需要的时候可以调用pop函数删除清理程序。</p><h2 id="线程同步"><a href="#线程同步" class="headerlink" title="线程同步"></a>线程同步</h2><h3 id="互斥量"><a href="#互斥量" class="headerlink" title="互斥量"></a>互斥量</h3><p>为了保证线程同步,多线程编程构建了一种锁的形式，当一个线程要操作某些变量的时候把这些变量的锁锁住，这样当其他线程想要操作这些变量的时候，就需要等待该线程操作完成并解锁。</p><p>锁即本小章的互斥量(<strong>下文中以mutex表示互斥量</strong>)</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pthread_mutex_t</span> mutex;</span><br></pre></td></tr></table></figure><p>互斥量需要初始化</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_mutex_init</span><span class="params">(*mutex，属性)</span></span>;<span class="comment">//如果初始华为默认属性的互斥量就把属性置为NULL</span></span><br></pre></td></tr></table></figure><p>可以静态初始化</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pthread_mutex_t</span> f_lock = PTHREAD_MUTEX_INITIALIZER;</span><br></pre></td></tr></table></figure><p>如若用动态内存分配的方式创建互斥量，在释放内存时需要先行调用</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_mutex_destroy</span><span class="params">(*mutex)</span></span>;</span><br></pre></td></tr></table></figure><ul><li>加锁和解锁</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_mutex_lock</span><span class="params">(*mutex)</span></span>;<span class="comment">//当互斥量被别的线程锁住时，lock函数会阻塞掉本线程</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_mutex_trylock</span><span class="params">(*mutex)</span></span>;<span class="comment">//当互斥量被别的线程锁住时，trylock函数不会阻塞掉本线程，而会返回EBUSY</span></span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_mutex_unlock</span><span class="params">(*mutex)</span></span>;<span class="comment">//解锁</span></span><br></pre></td></tr></table></figure><ul><li>设定等待锁的时间</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_mutex_timelock</span><span class="params">(*mutex,*tsptr)</span></span>;<span class="comment">//阻塞等待tsptr的时间</span></span><br></pre></td></tr></table></figure><p>eg:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">timespec</span> <span class="title">tout</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//获取当前时间</span></span><br><span class="line">clock_gettime(CLOCK_REALTIME,&amp;tout);</span><br><span class="line"></span><br><span class="line"><span class="comment">//打印时间</span></span><br><span class="line">tmp = locaktime(&amp;tout.tv_sec);</span><br><span class="line"><span class="built_in">sprintf</span>(buf,<span class="keyword">sizeof</span>(buf),<span class="string">&quot;%r&quot;</span>,tmp);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%s&quot;</span>,buf);</span><br><span class="line"></span><br><span class="line"><span class="comment">//等待10秒</span></span><br><span class="line">tout.tv_sec+=<span class="number">10</span>;</span><br><span class="line">err = pthread_mutex_timelock(&amp;mutex,&amp;tout);</span><br></pre></td></tr></table></figure><h3 id="读写锁"><a href="#读写锁" class="headerlink" title="读写锁"></a>读写锁</h3><p>读写锁也叫共享互斥锁，它有三种工作状态，读锁，写锁和无锁，读锁状态时可以允许其他线程进行读取，写锁状态只能单独使用。注：当写锁申请时会阻塞掉后面的读锁（避免被读锁长期占据而无法满足写锁）</p><p>读写锁变量</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pthread_rwlock_t</span> rwlock;</span><br><span class="line">​</span><br><span class="line"><span class="comment">//初始化</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_rwlock_init</span><span class="params">(*rwlock,*attr)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_rwlock_destory</span><span class="params">(*rwlock)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//锁与解锁</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_rwlock_rdlock</span><span class="params">(*rwlock)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_rwlock_wrlock</span><span class="params">(*rwlock)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_rwlock_unlock</span><span class="params">(*rwlock)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//条件版本</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_rwlock_tryrdlock</span><span class="params">(*rwlock)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_rwlock_trywrlock</span><span class="params">(*rwlock)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//带超时版本</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_rwlock_timerdlock</span><span class="params">(*rwlock,*tout)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_rwlock_timewrlock</span><span class="params">(*rwlock,*tout)</span></span>;</span><br></pre></td></tr></table></figure><h3 id="条件变量"><a href="#条件变量" class="headerlink" title="条件变量"></a>条件变量</h3><p> 用来等待某些操作完成，或者进行同步。</p><p>条件本身由互斥量进行保护。</p><p>条件变量<code>pthread_cond_t</code></p><p>初始化：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_cond_init</span><span class="params">(*cond,*attr)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_cond_destory</span><span class="params">(*cond)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_cond_wait</span><span class="params">(*cond,*mutex)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_cond_timewait</span><span class="params">(*cond,*mutex,*tsptr)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//发信号，换新等待的线程</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_cond_signal</span><span class="params">(*cond)</span></span>;<span class="comment">//唤醒一个及以上</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_cond_broadcast</span><span class="params">(*cond)</span></span>;<span class="comment">//</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="自旋锁"><a href="#自旋锁" class="headerlink" title="自旋锁"></a>自旋锁</h3><p>自旋锁在阻塞时不进行休眠，而是在获得锁之前一直处于忙等（自旋）阻塞状态。一般用于以下情况：锁被持有的时间<strong>短</strong>，而线程不希望在重新调度上花费太多成本。自旋锁在阻塞时，CPU不能做其他的事情。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pthread_spinlock_t</span> spin;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_spin_init</span><span class="params">(*spin,*attr)</span></span>;</span><br><span class="line"><span class="comment">//...同上</span></span><br></pre></td></tr></table></figure><h3 id="屏障"><a href="#屏障" class="headerlink" title="屏障"></a>屏障</h3><p>允许任意数量的线程等待，直到所有合作线程完成工作，而且线程不需要退出。当所有线程到达屏障后可以接着工作。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pthread_barrier_t</span> barrier;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_barrier_init</span><span class="params">(*barrier,*attr,count)</span><span class="comment">//count数量，允许运行前达到屏障的线程数量</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_barrier_destory</span><span class="params">(*barrier)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_barrier_wait</span><span class="params">(*barrier)</span></span>;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="线程属性"><a href="#线程属性" class="headerlink" title="线程属性"></a>线程属性</h2><p>在线程创建中我们在线程属性的参数输入了NULL作为默认值，这里我们将了解更多的线程属性，以及它们的作用。</p><p>线程属性一共有四个：</p><ul><li>detachstate：线程分离状态属性</li><li>guardsize：线程末尾的警戒缓冲区大小</li><li>stackaddr：线程栈的最低地址</li><li>stacksize：线程栈的最小长度</li></ul><p>线程属性使用一个<code>pthread_attr_t</code>变量来设定，使用<code>pthread_attr_init</code>初始化，使用<code>pthread_attr_destroy</code>反初始化。</p><h3 id="修改线程分离状态"><a href="#修改线程分离状态" class="headerlink" title="修改线程分离状态"></a>修改线程分离状态</h3><p>如果对某个线程的终止状态不感兴趣的话，可以使用<code>pthread_detach</code>函数让操作系统在线程退出时回收线程所占用的资源。但如果在创建线程时就知道不需要了解线程的终止状态，就可以修改线程属性中的detachstate属性，让线程一开始就处于分离状态。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*获取当前的detachstate线程属性*/</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_attr_getdetachstate</span><span class="params">(<span class="keyword">const</span> <span class="keyword">pthread_attr_t</span> *<span class="keyword">restrict</span> attr,<span class="keyword">int</span> *detachstate)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*设置attr变量的detachstate值，后面的参数可以是PTHREAD_CREATE_DETACHED和PTHREAD_CREATE_JOINABLE两种属性值*/</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_attr_setdetachstate</span><span class="params">(<span class="keyword">pthread_attr_t</span> *attr,<span class="keyword">int</span> *detachstate)</span></span>;</span><br></pre></td></tr></table></figure><h3 id="修改线程栈属性"><a href="#修改线程栈属性" class="headerlink" title="修改线程栈属性"></a>修改线程栈属性</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_attr_getstack</span><span class="params">(<span class="keyword">const</span> <span class="keyword">pthread_attr_t</span> *<span class="keyword">restrict</span> attr,</span></span></span><br><span class="line"><span class="params"><span class="function">                          <span class="keyword">void</span> **<span class="keyword">restrict</span> strackaddr,</span></span></span><br><span class="line"><span class="params"><span class="function">                          <span class="keyword">size_t</span> *<span class="keyword">restrict</span> stracksize)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_attr_setstack</span><span class="params">(<span class="keyword">pthread_attr_t</span>  attr,<span class="keyword">void</span> *strackaddr,<span class="keyword">size_t</span> stracksize)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*仅改变大小*/</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_attr_getstacksize</span><span class="params">(<span class="keyword">const</span> <span class="keyword">pthread_attr_t</span> *<span class="keyword">restrict</span> attr,</span></span></span><br><span class="line"><span class="params"><span class="function">                              <span class="keyword">size_t</span> *<span class="keyword">restrict</span> stracksize)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_attr_setstacksize</span><span class="params">(<span class="keyword">pthread_attr_t</span> *attr, <span class="keyword">size_t</span> stracksize)</span></span>;</span><br></pre></td></tr></table></figure><h3 id="修改线程缓冲区大小"><a href="#修改线程缓冲区大小" class="headerlink" title="修改线程缓冲区大小"></a>修改线程缓冲区大小</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_attr_getguardsize</span><span class="params">(<span class="keyword">const</span> <span class="keyword">pthread_attr_t</span> *<span class="keyword">restrict</span> attr,</span></span></span><br><span class="line"><span class="params"><span class="function">                              <span class="keyword">size_t</span> *<span class="keyword">restrict</span> stracksize)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_attr_setguardsize</span><span class="params">(<span class="keyword">pthread_attr_t</span> *attr,<span class="keyword">size_t</span> stracksize)</span></span>;</span><br></pre></td></tr></table></figure><h2 id="同步属性"><a href="#同步属性" class="headerlink" title="同步属性"></a>同步属性</h2><h3 id="互斥量属性"><a href="#互斥量属性" class="headerlink" title="互斥量属性"></a>互斥量属性</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//互斥量属性</span></span><br><span class="line"><span class="keyword">pthread_mutexattr_t</span> attr;</span><br><span class="line"></span><br><span class="line"><span class="comment">//初始化与反初始化</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_mutexattr_init</span><span class="params">(<span class="keyword">pthread_mutexattr_t</span> *attr)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_mutexattr_destroy</span><span class="params">(<span class="keyword">pthread_mutexattr_t</span> *attr)</span></span>;</span><br><span class="line"><span class="comment">//成功返回0，失败返回错误编号</span></span><br></pre></td></tr></table></figure><p>互斥量属性中，有三个值得注意的属性，分别是：进程共享属性，健壮属性，类型属性</p><ul><li><p>进程共享属性</p><p>进程共享属性的互斥量属性设为<code>PTHREAD_PROCESS_PRIVATE</code>，这样就是默认的属性，进程内部多个线程共用；如果进程共享属性互斥量设为<code>PTHREAD_PROCESS_SHARED</code>,从多个进程彼此之间共享的内存数据块中分配的互斥量就可以用于这些进程的同步。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_mutexattr_getpshared</span><span class="params">(<span class="keyword">const</span> <span class="keyword">pthread_mutexattr_t</span> *<span class="keyword">restrict</span> attr, </span></span></span><br><span class="line"><span class="params"><span class="function">                                 <span class="keyword">int</span> *<span class="keyword">restrict</span> pshared)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_mutexattr_setpshared</span><span class="params">(<span class="keyword">pthread_mutexattr_t</span> *attr, <span class="keyword">int</span> pshared)</span></span>;</span><br></pre></td></tr></table></figure></li><li><p>健壮属性</p><p>互斥量的健壮属性和之前的进程共享属性有关，当一个持有互斥量的进程终止时，需要解决互斥量的恢复问题。这种情况发生时，互斥量处于锁定状态，恢复起来困难，其他阻塞在这个锁的进程就会一直阻塞下去。健壮属性有两种属性：<code>PTHREAD_MUTEX_STALLED</code>及默认属性，等待互斥量解锁的应用程序会被有效地“拖住”，<strong>另一个取值<code>PTHREAD_MUTEX_ROBUST</code>时，当一个进程调用<code>pthread_mutex_lock</code>获取锁，而锁被另一个进程持有，且终止时没有解锁，此时进程会阻塞，但从<code>pthread_mutex_lock</code>返回的值为EOWNERDEAD而不是0，应用程序可以通过这个特殊的返回值得知，互斥量需要进行恢复。</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_mutexattr_getrobust</span><span class="params">(<span class="keyword">const</span> <span class="keyword">pthread_mutexattr_t</span> *<span class="keyword">restrict</span> attr, <span class="keyword">int</span> *<span class="keyword">restrict</span> rubust)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_mutexattr_setrobust</span><span class="params">(<span class="keyword">pthread_mutexattr_t</span> *attr, <span class="keyword">int</span> robust)</span></span>;</span><br></pre></td></tr></table></figure><ul><li>恢复：如果应用状态无法恢复，<strong>在线程对互斥量解锁以后，该互斥量将处于永久不可用状态？？？</strong>。为了避免这样的问题，线程可以调用<code>pthread_mutex_consistent</code>函数，指明与该互斥量相关的状态在互斥量解锁前时一致的。。unix环境p347页</li></ul></li><li><p>类型属性</p><p>互斥量类型属性控制互斥量的<strong>锁定特性</strong>，</p><ul><li>PTHREAD_MUTEX_NORMAL<ul><li>标准的互斥量类型，不做特殊的错误检查或死锁检测</li></ul></li><li>PTHREAD_MUTEX_ERRORCHECK<ul><li>提供错误检查</li></ul></li><li>PTHREAD_MUTEX_RECURSIVE<ul><li>允许同一线程在互斥量解锁前进行多次加锁（递归加锁）</li></ul></li><li>PTHREAD_MUTEX_DEFAULT<ul><li>默认类型，供给操作系统映射到标准类型或错误检查类型</li></ul></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_mutexattr_gettype</span><span class="params">(<span class="keyword">const</span> <span class="keyword">pthread_mutexattr_t</span> *<span class="keyword">restrict</span> attr, </span></span></span><br><span class="line"><span class="params"><span class="function">                              <span class="keyword">int</span> *<span class="keyword">restrict</span> type)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_mutexattr_settype</span><span class="params">(<span class="keyword">pthread_mutexattr_t</span> *attr, <span class="keyword">int</span> type)</span></span>;</span><br></pre></td></tr></table></figure><h3 id="读写锁属性"><a href="#读写锁属性" class="headerlink" title="读写锁属性"></a>读写锁属性</h3></li></ul><p>读写锁和互斥锁一样拥有属性，不过读写锁只支持<strong>进程共享属性</strong>。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//读写锁属性</span></span><br><span class="line"><span class="keyword">pthread_rwlockattr_t</span> attr;</span><br><span class="line"></span><br><span class="line"><span class="comment">//初始化与反初始化</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_rwlockattr_init</span><span class="params">(<span class="keyword">pthread_rwlockattr_t</span> *attr)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_rwlockattr_destroy</span><span class="params">(<span class="keyword">pthread_rwlockattr_t</span> *attr)</span></span>;</span><br><span class="line"><span class="comment">//成功返回0，失败返回错误编号</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_rwlockattr_getpshared</span><span class="params">(<span class="keyword">const</span> <span class="keyword">pthread_rwlockattr_t</span> *<span class="keyword">restrict</span> attr, </span></span></span><br><span class="line"><span class="params"><span class="function">                                  <span class="keyword">int</span> *<span class="keyword">restrict</span> pshared)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_rwlockattr_setpshared</span><span class="params">(<span class="keyword">pthread_rwlockattr_t</span> *attr, <span class="keyword">int</span> pshared)</span></span>;</span><br></pre></td></tr></table></figure><h3 id="条件变量属性"><a href="#条件变量属性" class="headerlink" title="条件变量属性"></a>条件变量属性</h3><p>条件变量定义了两个属性：<strong>进程共享属性</strong>和<strong>时钟属性</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//条件变量属性</span></span><br><span class="line"><span class="keyword">pthread_condattr_t</span> attr;</span><br><span class="line"></span><br><span class="line"><span class="comment">//初始化与反初始化</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_condattr_init</span><span class="params">(<span class="keyword">pthread_condattr_t</span> *attr)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_condattr_destroy</span><span class="params">(<span class="keyword">pthread_condattr_t</span> *attr)</span></span>;</span><br><span class="line"><span class="comment">//成功返回0，失败返回错误编号</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_condattr_getpshared</span><span class="params">(<span class="keyword">const</span> <span class="keyword">pthread_condattr_t</span> *<span class="keyword">restrict</span> attr,</span></span></span><br><span class="line"><span class="params"><span class="function">                                <span class="keyword">int</span> *<span class="keyword">restrict</span> pshared)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_condattr_setpshared</span><span class="params">(<span class="keyword">pthread_condattr_t</span> *attr, <span class="keyword">int</span> pshared)</span></span>;</span><br></pre></td></tr></table></figure><p>s时钟属性控制<code>pthread_cond_timewait</code>函数的超时参数采用的哪个时钟</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_condattr_getclock</span><span class="params">(<span class="keyword">const</span> <span class="keyword">pthread_condattr_t</span> *<span class="keyword">restrict</span> attr,</span></span></span><br><span class="line"><span class="params"><span class="function">                              <span class="keyword">clockid_t</span> *<span class="keyword">restrict</span> clock_id)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_condattr_setclock</span><span class="params">(<span class="keyword">pthread_condattr_t</span> *attr, <span class="keyword">clockid_t</span> clock_id)</span></span>;</span><br></pre></td></tr></table></figure><h3 id="屏障属性"><a href="#屏障属性" class="headerlink" title="屏障属性"></a>屏障属性</h3><p>屏障目前只定义了一个属性，<strong>进程共享属性</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//屏障属性</span></span><br><span class="line"><span class="keyword">pthread_barrierattr_t</span> attr;</span><br><span class="line"></span><br><span class="line"><span class="comment">//初始化与反初始化</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_barrierattr_init</span><span class="params">(<span class="keyword">pthread_barrierattr_t</span> *attr)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_barrierattr_destroy</span><span class="params">(<span class="keyword">pthread_barrierattr_t</span> *attr)</span></span>;</span><br><span class="line"><span class="comment">//成功返回0，失败返回错误编号</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_barrierattr_getpshared</span><span class="params">(<span class="keyword">const</span> <span class="keyword">pthread_barrierattr_t</span> *<span class="keyword">restrict</span> attr, </span></span></span><br><span class="line"><span class="params"><span class="function">                                  <span class="keyword">int</span> *<span class="keyword">restrict</span> pshared)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_barrierattr_setpshared</span><span class="params">(<span class="keyword">pthread_barrierattr_t</span> *attr, <span class="keyword">int</span> pshared)</span></span>;</span><br></pre></td></tr></table></figure><h2 id="重入"><a href="#重入" class="headerlink" title="重入"></a>重入</h2><p>暂略</p><h2 id="线程特定数据"><a href="#线程特定数据" class="headerlink" title="线程特定数据"></a>线程特定数据</h2><p>如果在函数体内不访问那些<a href="http://baike.baidu.com/view/261041.htm">全局变量</a>，不使用<a href="http://baike.baidu.com/view/612026.htm">静态</a><a href="http://baike.baidu.com/view/552847.htm">局部变量</a>，坚持只使用局部变量，写出的函数就将是可重入的。如果必须访问<a href="http://baike.baidu.com/view/261041.htm">全局变量</a>，记住利用互斥<a href="http://baike.baidu.com/view/1303265.htm">信号量</a>来保护全局变量。如果多个线程同时访问一个函数，而这个函数恰好也必须使用一个静态变量，那么，线程特定数据就是来解决这个问题的。</p><p>在分配特定数据前，需要先创建一个键</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_key_create</span><span class="params">(<span class="keyword">pthread_key_t</span> *keyp,<span class="keyword">void</span> (*destructor)(<span class="keyword">void</span> *))</span></span>;</span><br></pre></td></tr></table></figure><p>创建键的同时也可以为该键关联一个可选择的析构函数，当这个线程退出时，如果数据地址已经被置为非空值，那么析构函数就会被调用，它唯一的参数就是该数据地址。线程取消时，在最后的清理处理程序返回之后，析构函数才会被调用。当线程非正常（exit,_exit,Exit和abort等）退出就不会调用析构函数。</p><p>为了防止重复创建<strong>键</strong>，使用<code>pthread_once</code>函数解决</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pthread_once_t</span> initflag = PTHREAD_ONCE_INIT;<span class="comment">//必须为非本地变量（如全局变量或静态变量）</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_once</span><span class="params">(<span class="keyword">pthread_once_t</span> *initflag, <span class="keyword">void</span> (*initfn)(<span class="keyword">void</span>))</span></span>;</span><br></pre></td></tr></table></figure><p>键一但创建以后，就可以通过调用<code>pthread_setspecific</code>把键与线程特定数据关联起来，以及通过<code>pthread_getspecific</code>函数获取线程特定数据的地址。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">pthread_getspecific</span><span class="params">(<span class="keyword">pthread_key_t</span> key)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_setspecific</span><span class="params">(<span class="keyword">pthread_key_t</span> key,<span class="keyword">const</span> <span class="keyword">void</span> *value)</span></span>;</span><br></pre></td></tr></table></figure><p>对于所有的线程，我们可以调用<code>pthread_key_delete</code>来取消键与线程特定数据值之间的关联关系。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_key_delete</span><span class="params">(<span class="keyword">pthread_key_t</span> key)</span></span>;</span><br></pre></td></tr></table></figure><h2 id="取消选项"><a href="#取消选项" class="headerlink" title="取消选项"></a>取消选项</h2><p>有两个线程属性没有包含在<code>pthread_attr_t</code>结构中，它们时可取消状态和可取消类型</p><p><strong>可取消状态</strong>可以通过下面函数进行更改</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_setcancelstate</span><span class="params">(<span class="keyword">int</span> state,<span class="keyword">int</span> *oldstate)</span></span>;</span><br></pre></td></tr></table></figure><p>有两种状态<code>PTHREAD_CANCEL_ENABLE</code>和<code>PTHREAD_CANCEL_DISABLE</code>，当线程处于<code>PTHREAD_CANCEL_DISABLE</code>状态时，对<code>pthread_cancel</code>的调用并不会杀死线程，而是将取消请求置于挂起状态，直到线程取消状态再次变成<code>PTHREAD_CANCEL_ENABLE</code>时，线程将在下一个取消点对挂起的取消请求进行处理。</p><p>如果程序很长时间不会调用取消点定义的函数，可以自己调用<code>pthread_testcancel</code>函数在程序中添加取消点。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">pthread_testcancel</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br></pre></td></tr></table></figure><p><strong>可取消类型</strong>可以调用<code>pyhread_setcanceltype(int type, int *oldtype)</code>函数来修改取消类型，我们默认的取消类型是推迟取消，在线程到达取消点之前不会真正取消。取消类型有两个类型参数<code>PTHREAD_CANCEL_DEFERRED</code>和<code>PTHREAD_CANCEL_ASYNCHRONOUS</code>，异步取消与推迟取消不同，使用异步取消的线程可以在任意时间退出，不一定需要遇到取消点。</p><h2 id="线程和信号"><a href="#线程和信号" class="headerlink" title="线程和信号"></a>线程和信号</h2>]]></content>
      
      
      <categories>
          
          <category> UNIX环境高级编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 多线程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>GDB调试笔记</title>
      <link href="/2022/01/06/gdb-diao-shi-bi-ji/"/>
      <url>/2022/01/06/gdb-diao-shi-bi-ji/</url>
      
        <content type="html"><![CDATA[<blockquote><p>2020年实习时，由于需要频繁用到GDB调试，特此记录GDB调试使用的一些常用命令记录</p></blockquote><span id="more"></span><h4 id="启动"><a href="#启动" class="headerlink" title="启动"></a>启动</h4><p>使用GDB在编译时需要加上-g，没有-g将看不见函数名，变量名，取代的是内存地址</p><h5 id="运行程序"><a href="#运行程序" class="headerlink" title="运行程序"></a>运行程序</h5><ul><li><p><code>gdb+执行文件/路径</code></p></li><li><p><code>gdb+执行文件+core文件</code></p></li><li><p><code>gdb+执行文件+PID（进程ID</code></p></li></ul><h5 id="调试已经运行的程序："><a href="#调试已经运行的程序：" class="headerlink" title="调试已经运行的程序："></a>调试已经运行的程序：</h5><ul><li>ps查看程序运行的PID，然后用上面的命令<code>gdb+执行文件+PID</code>（进程ID）</li><li>先用<code>pdb+执行文件</code> 关联上源代码，再用<code>attach</code>挂接进程的PID，用<code>detach</code>取消挂接的进程。</li></ul><h4 id="基础命令"><a href="#基础命令" class="headerlink" title="基础命令"></a>基础命令</h4><table><thead><tr><th>命令</th><th>功能</th></tr></thead><tbody><tr><td>l(list)</td><td>从第一行列出代码</td></tr><tr><td>break+行号</td><td>从16行设置断点</td></tr><tr><td>break func</td><td>设置断点在func入口处</td></tr><tr><td>info break</td><td>查看断点信息</td></tr><tr><td>r (run)</td><td>运行程序</td></tr><tr><td>n(next)</td><td>执行下一句，不会进入函数</td></tr><tr><td>s(step)</td><td>执行下一句，会进入函数</td></tr><tr><td>c(continue)</td><td>继续运行程序</td></tr><tr><td>p 变量名(print 变量名)</td><td>打印变量i的值</td></tr><tr><td>bt</td><td>查看函数堆栈</td></tr><tr><td>finish</td><td>退出函数</td></tr><tr><td>q</td><td>退出GDB</td></tr><tr><td>s(symbols)+file</td><td>从指定文件中读取符号表</td></tr><tr><td>c/core file</td><td>调试时core dump的core文件</td></tr><tr><td>d/directory file</td><td>加入一个源文件的搜索路径</td></tr></tbody></table><p><code>until</code>运行命令到退出循环体</p><p><code>stepi</code>和<code>nexti</code>单步执行一条机器指令</p><ul><li><p>打印结构体分行显示</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">set print pretty on </span><br></pre></td></tr></table></figure></li></ul><h4 id="暂停程序"><a href="#暂停程序" class="headerlink" title="暂停程序"></a>暂停程序</h4><h5 id="停止点"><a href="#停止点" class="headerlink" title="停止点"></a>停止点</h5><ul><li><p>断点<code>break+行号/函数</code></p></li><li><p><em>可以通过条件设置（break if 条件）</em>*</p></li><li><p><em>修改条件可以通过 condition+断点号+新条件</em>*</p></li><li><p>观察点<code>watch+变量名</code>（值发生变化会暂停）</p><ul><li><code>rwatch +变量名</code>（变量被读时暂停）</li><li><code>awatch+变量名</code>（读和写）</li></ul></li><li><p>捕捉点<code>catch</code></p></li></ul><h5 id="停止点维护"><a href="#停止点维护" class="headerlink" title="停止点维护"></a>停止点维护</h5><p>  <code>clear</code>清除所有停止点，可以加行号，函数指定清除的点<br>  <code>delete +断点号+范围</code><br>  <u><strong>clear和delete有啥区别</strong></u><br>  <code>disable和enable</code> 关掉和启动停止点</p><h5 id="特殊命令："><a href="#特殊命令：" class="headerlink" title="特殊命令："></a>特殊命令：</h5><ul><li><code>ignore+断点号+次数</code>程序运行时忽略该断点次数</li><li><code>commands+断点号 +命令列表+end</code>当断点触发时运行的命令列表中的命令，有利于自动测试</li></ul>  <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">commands 断点号</span><br><span class="line">  command-list</span><br><span class="line">end</span><br></pre></td></tr></table></figure><h5 id="信号"><a href="#信号" class="headerlink" title="信号"></a>信号</h5><p>信号是一种软中断，是一种处理异步事件的方法。一般来说，操作系统都支持许多信号。尤其是UNIX，比较重要应用程序一般都会处理信号。UNIX 定义了许多信号，比如SIGINT表示中断字符信号，也就是Ctrl+C的信号，SIGBUS表示硬件故障的信号；SIGCHLD表示子进程状态改变信号；SIGKILL表示终止程序运行的信号，等等。信号量编程是UNIX 下非常重要的一种技术。</p><p>定义GDB在调试过程中，当收到某种信号时的动作/停下/打印信息等等</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">handle+信号+处理方式</span><br></pre></td></tr></table></figure><p>处理方式：</p><p><code>Nostop</code>-不停下，但打印信息</p><p><code>stop</code>-停下</p><p>   <code>noprint</code>-不打印信息</p><p>   <code>pass</code></p><p><code>noignore</code>-GDB不处理该信号，交给被测程序处理</p><p><code>nopass</code></p><p><code>ignore</code>-不让被测程序处理</p><p><code>info signals</code></p><p><code>info handle</code></p><p>查看哪些信号被GDB检测中</p><h5 id="多线程"><a href="#多线程" class="headerlink" title="多线程"></a>多线程</h5><p>GDB可以指定断点在某一线程上**<code>break+行号+thread+线程ID</code>**</p><p>线程ID需要通过GDB查看，命令**<code>info threads</code>**</p><p>多线程调试时，可以取消线程轮转来进行单步调试（断到具体的函数，取消轮转，单步调试）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(gdb) set scheduler-locking on</span><br><span class="line">(gdb) set scheduler-locking off</span><br></pre></td></tr></table></figure><h4 id="检查信息"><a href="#检查信息" class="headerlink" title="检查信息"></a>检查信息</h4><h5 id="栈信息"><a href="#栈信息" class="headerlink" title="栈信息"></a>栈信息</h5><p>查看栈信息<code>backtrace/bt</code>可以加一个数n,表示只打印栈顶n行</p><p>查看当前栈详细信息<code>info frame/f</code></p><p>切换当前栈<code>frame/f</code>,同理加n，也可以用**<code>up和down</code>**上下移动</p><h5 id="搜索"><a href="#搜索" class="headerlink" title="搜索"></a>搜索</h5><p><code>forward-search 条件</code> 向前搜索</p><p><code>search 条件</code> 向后搜索</p><p><code>reverse-search 条件</code> 全局搜索</p><p>条件为正则表达式形式</p><h5 id="查看内存"><a href="#查看内存" class="headerlink" title="查看内存"></a>查看内存</h5><ul><li><p>查看源代码在运行时的地址</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">info line 行号/文件名：行号/文件名：函数名</span><br></pre></td></tr></table></figure></li><li><p>查看源程序的当前执行时的机器码</p> <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">disassemble func</span><br><span class="line"><span class="meta">#</span><span class="bash"> 会打印出函数func的汇编代码</span></span><br></pre></td></tr></table></figure></li><li><p>查看内存地址中的值</p> <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">examine命令，简写x</span></span><br><span class="line">x n/f/u addr</span><br><span class="line"><span class="meta">#</span><span class="bash">n 是一个正整数，表示显示内存的长度，也就是说从当前地址向后显示几个地址的内容。</span></span><br><span class="line"><span class="meta">#</span><span class="bash">f 表示显示的格式，参见上面。如果地址所指的是字符串，那么格式可以是s，如果地十是指令地址，那么格式可以是i。</span></span><br><span class="line"><span class="meta">#</span><span class="bash">u 表示从当前地址往后请求的字节数，如果不指定的话，GDB默认是4个bytes。u 参数可以用下面的字符来代替，b 表示单字节，h 表示双字节，w 表示四字节，g 表示八字节。当我们指定了字节长度后，GDB 会从指内存定的内存地址开始，读写指定字节，并把其当作一个值取出来。</span></span><br><span class="line"><span class="meta">#</span><span class="bash">n/f/u可以一起使用</span></span><br></pre></td></tr></table></figure></li></ul><h5 id="自动显示"><a href="#自动显示" class="headerlink" title="自动显示"></a>自动显示</h5><p>你可以设置一些自动显示的变量，当程序停住时，或是在你单步跟踪时，这些变量会自动显示。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">display 表达式</span><br><span class="line">display 地址</span><br><span class="line">display/格式 地址或表达式</span><br></pre></td></tr></table></figure><h5 id="查看寄存器"><a href="#查看寄存器" class="headerlink" title="查看寄存器"></a>查看寄存器</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">info registers</span><br><span class="line"><span class="meta">#</span><span class="bash">查看寄存器的情况。（除了浮点寄存器）</span></span><br><span class="line">info all-registers</span><br><span class="line"><span class="meta">#</span><span class="bash">查看所有寄存器的情况。（包括浮点寄存器）</span></span><br><span class="line">info registers &lt;regname ...&gt;</span><br><span class="line"><span class="meta">#</span><span class="bash">查看所指定的寄存器的情况。</span></span><br></pre></td></tr></table></figure><h4 id="改变程序的运行"><a href="#改变程序的运行" class="headerlink" title="改变程序的运行"></a>改变程序的运行</h4><h5 id="修改变量值"><a href="#修改变量值" class="headerlink" title="修改变量值"></a>修改变量值</h5><p>修改程序运行时的变量值</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">print x=4</span><br></pre></td></tr></table></figure><p>如果变量名和gdb参数冲突，可以使用<code>set var</code> 告诉GDB这个是程序的变量名。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">set var width=47</span><br></pre></td></tr></table></figure><p><strong>在有些时候GDB并不会报告这类错误，因此都推荐使用<code>set var</code>的格式修改变量值</strong></p><h5 id="跳转执行"><a href="#跳转执行" class="headerlink" title="跳转执行"></a>跳转执行</h5><p>GDB提供了修改程序的执行顺序的功能，跳转功能，直接跳转到某个语句继续执行</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">jump 行号</span><br><span class="line">jump 代码行的内存地址</span><br></pre></td></tr></table></figure><p><strong>注：跳转并不会改变当前程序栈的内容，所以最好在一个函数内跳转，当你从一个函数跳到另一个函数，函数执行完进行弹栈操作时必然发生错误</strong></p><h5 id="产生信号量"><a href="#产生信号量" class="headerlink" title="产生信号量"></a>产生信号量</h5><p>GDB可以使用<code>singal</code>命令，在断点处由GDB产生一个信号量给被调试程序</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">singal &lt;singal&gt;</span><br></pre></td></tr></table></figure><h5 id="强制函数返回"><a href="#强制函数返回" class="headerlink" title="强制函数返回"></a>强制函数返回</h5><p>如果你的调试断点在某个函数中，并还有语句没有执行完，你可以使用return命令强制函数忽略后面未执行的语句并返回</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">return</span><br><span class="line">return 返回值</span><br></pre></td></tr></table></figure><h5 id="强制调用函数"><a href="#强制调用函数" class="headerlink" title="强制调用函数"></a>强制调用函数</h5><ul><li><p>call命令 </p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">call 函数</span><br><span class="line"><span class="meta">#</span><span class="bash">强制调用函数，并显示返回值，如果返回值时void就不显示</span></span><br></pre></td></tr></table></figure></li><li><p>print 命令</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">print 函数</span><br><span class="line"><span class="meta">#</span><span class="bash">如果函数返回void依旧会显示，并把该值存入历史数据</span></span><br></pre></td></tr></table></figure></li></ul>]]></content>
      
      
      <categories>
          
          <category> 工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> GDB </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/2022/01/06/hello-world/"/>
      <url>/2022/01/06/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
